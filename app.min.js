

// ============================================ 
// OPTIMIZED SUPERCUT AND MARKER VIDEO EDITOR 
// Complete rewrite with all bug fixes applied 
// ============================================ 

document.addEventListener('DOMContentLoaded', function() {
    $(function() {
        
        // ============================================ 
        // VIDEO TIMELINE CONTROLLER CLASS 
        // ============================================ 
        class VideoTimelineController {
            constructor(config) {
                // DOM elements
                this.video = config.video;
                this.mainTimeline = config.mainTimeline;
                this.mainTimelineSelection = config.mainTimelineSelection;
                this.mainTimelinePlayhead = config.mainTimelinePlayhead;
                this.currentTimeDisplay = config.currentTimeDisplay;
                this.durationTimeDisplay = config.durationTimeDisplay;
                this.selectionTimeDisplay = config.selectionTimeDisplay;
                this.selectionDurationDisplay = config.selectionDurationDisplay;
                this.detectedFpsDisplay = config.detectedFpsDisplay;
                this.framerateSelect = config.framerateSelect;
                
                // State management
                this.state = {
                    frameRate: 29.97,
                    duration: 0,
                    currentTime: 0,
                    selection: { start: 0, end: 0 },
                    isWaveformReady: false,
                    isSeeking: false,
                    isLooping: false,
                    isDragging: false,
                    markers: [],
                    activeMarkerIndex: -1
                };
                
                // Performance optimization
                this.rafId = null;
                this.lastUpdateTime = 0;
                this.updateThrottle = 1000 / 60; // 60fps max
                
                // WaveSurfer instance
                this.wavesurfer = null;
                this.selectionRegion = null;
                
                // FPS detection
                this.fpsDetector = {
                    lastMediaTime: 0,
                    lastFrameNum: 0,
                    fpsRounder: [],
                    frameNotSeeked: true,
                    detectedFps: 0,
                    isComplete: false
                };
                
                // SMPTE cache
                this.smpteCache = new Map();
                this.lastCacheTime = -1;
                this.lastScaleUpdate = -1;
                
                // Bind methods
                this.updatePlayhead = this.updatePlayhead.bind(this);
                this.handleTimeUpdate = this.handleTimeUpdate.bind(this);
                this.ticker = this.ticker.bind(this);
                
                this.init();
            }
            
            init() {
                // Ensure video controls are always visible
                this.video.setAttribute('controls', 'true');
                this.video.setAttribute('controlsList', 'nodownload');
                
                // Video event listeners
                this.video.addEventListener('loadedmetadata', () => this.onVideoLoaded());
                this.video.addEventListener('timeupdate', this.handleTimeUpdate);
                this.video.addEventListener('seeking', () => { 
                    this.state.isSeeking = true;
                    if (window.app) {
                        window.app.renderTimelineMarkers();
                    }
                });
                this.video.addEventListener('seeked', () => { 
                    this.state.isSeeking = false;
                    this.fpsDetector.fpsRounder.pop();
                    this.fpsDetector.frameNotSeeked = false;
                    this.updatePlayhead(true);
                });
                this.video.addEventListener('play', () => this.onPlayStateChange(true));
                this.video.addEventListener('pause', () => this.onPlayStateChange(false));
                
                // Handle native video control seeking
                this.video.addEventListener('input', () => {
                    this.updatePlayhead(true);
                    this.updateTimeDisplaysCached(this.video.currentTime);
                });
                
                // Timeline interaction
                this.setupTimelineInteraction();
                
                // Frame rate change handler
                this.framerateSelect.addEventListener('change', (e) => {
                    this.state.frameRate = parseFloat(e.target.value);
                    this.smpteCache.clear();
                    this.updateTimeDisplaysCached();
                });
            }
            
            onVideoLoaded() {
                this.state.duration = this.video.duration;
                this.state.selection = { start: 0, end: this.video.duration };
                
                this.updateSelection();
                this.updateTimeDisplaysCached();
                
                if (!this.video.paused) {
                    this.startPlayheadAnimation();
                }
                
                // Reset FPS detection
                this.fpsDetector.isComplete = false;
                this.fpsDetector.fpsRounder = [];
                
                // Start FPS detection
                this.video.requestVideoFrameCallback(this.ticker);
            }
            
            onPlayStateChange(isPlaying) {
                const playPauseBtn = document.getElementById('play-pause');
                if (playPauseBtn) {
                    playPauseBtn.textContent = isPlaying ? 'Pause' : 'Play';
                }
                
                if (isPlaying) {
                    this.startPlayheadAnimation();
                } else {
                    this.stopPlayheadAnimation();
                    this.updatePlayhead(true);
                }
            }
            
            // ============================================ 
            // FPS DETECTION (OPTIMIZED) 
            // ============================================ 
            ticker(useless, metadata) {
                if (this.fpsDetector.isComplete) return;
                
                const mediaTimeDiff = Math.abs(metadata.mediaTime - this.fpsDetector.lastMediaTime);
                const frameNumDiff = Math.abs(metadata.presentedFrames - this.fpsDetector.lastFrameNum);
                const diff = mediaTimeDiff / frameNumDiff;
                
                if (diff && diff < 1 && this.fpsDetector.frameNotSeeked && 
                    this.fpsDetector.fpsRounder.length < 50 && 
                    this.video.playbackRate === 1 && document.hasFocus()) {
                    
                    this.fpsDetector.fpsRounder.push(diff);
                    const avgFps = this.fpsDetector.fpsRounder.reduce((a, b) => a + b) / this.fpsDetector.fpsRounder.length;
                    this.fpsDetector.detectedFps = Math.round(1 / avgFps);
                    
                    const certainty = this.fpsDetector.fpsRounder.length * 2;
                    this.detectedFpsDisplay.textContent = `${this.fpsDetector.detectedFps} fps (${certainty}%)`;
                    
                    if (certainty >= 50) {
                        const closestRate = this.findClosestFrameRate(this.fpsDetector.detectedFps);
                        this.framerateSelect.value = closestRate.toString();
                        this.state.frameRate = closestRate;
                        this.updateTimeDisplaysCached();
                    }
                    
                    if (this.fpsDetector.fpsRounder.length >= 50) {
                        this.fpsDetector.isComplete = true;
                        this.detectedFpsDisplay.textContent += ' âœ“';
                        return;
                    }
                }
                
                this.fpsDetector.frameNotSeeked = true;
                this.fpsDetector.lastMediaTime = metadata.mediaTime;
                this.fpsDetector.lastFrameNum = metadata.presentedFrames;
                
                if (!this.fpsDetector.isComplete) {
                    this.video.requestVideoFrameCallback(this.ticker);
                }
            }
            
            findClosestFrameRate(detectedFps) {
                const frameRates = [23.976, 24, 25, 29.97, 30, 50, 59.94, 60];
                return frameRates.reduce((prev, curr) => 
                    Math.abs(curr - detectedFps) < Math.abs(prev - detectedFps) ? curr : prev
                );
            }
            
            // ============================================ 
            // UNIFIED SEEK FUNCTION 
            // ============================================ 
            seekTo(time, source = 'user') {
                if (!this.state.duration) return;
                
                if (this.state.isSeeking && source === 'sync') return;
                
                time = Math.max(0, Math.min(this.state.duration, time));
                this.state.currentTime = time;
                
                if (this.state.isWaveformReady && this.wavesurfer) {
                    if (Math.abs(this.wavesurfer.getCurrentTime() - time) > 0.001) {
                        const progress = time / this.state.duration;
                        this.wavesurfer.seekAndCenter(progress);
                    }
                } else {
                    if (Math.abs(this.video.currentTime - time) > 0.001) {
                        this.video.currentTime = time;
                    }
                }
                
                this.updatePlayhead(true);
                this.updateTimeDisplaysCached();
                
                setTimeout(() => { this.state.isSeeking = false; }, 50);
            }
            
            // ============================================ 
            // OPTIMIZED PLAYHEAD UPDATE 
            // ============================================ 
            updatePlayhead(force = false) {
                const now = performance.now();
                
                if (!force && !this.video.paused && now - this.lastUpdateTime < this.updateThrottle) {
                    return;
                }
                
                this.lastUpdateTime = now;
                
                const currentTime = this.state.isWaveformReady && this.wavesurfer
                    ? this.wavesurfer.getCurrentTime()
                    : this.video.currentTime;
                
                if (this.state.duration > 0) {
                    const position = (currentTime / this.state.duration) * 100;
                    this.mainTimelinePlayhead.style.left = `${position}%`;
                }
                
                this.updateTimeDisplaysCached(currentTime);
            }
            
            // ============================================ 
            // ANIMATION LOOP 
            // ============================================ 
            startPlayheadAnimation() {
                if (this.rafId) return;
                
                const animate = () => {
                    if (!this.video.paused && !this.state.isSeeking) {
                        this.updatePlayhead();
                    }
                    
                    if (!this.video.paused) {
                        this.rafId = requestAnimationFrame(animate);
                    } else {
                        this.rafId = null;
                    }
                };
                
                if (!this.video.paused) {
                    animate();
                }
            }
            
            stopPlayheadAnimation() {
                if (this.rafId) {
                    cancelAnimationFrame(this.rafId);
                    this.rafId = null;
                }
            }
            
            // ============================================ 
            // TIMELINE INTERACTION 
            // ============================================ 
            setupTimelineInteraction() {
                let lastDragTime = 0;
                const dragThrottle = 16;
                
                const getTimeFromPosition = (e) => {
                    const rect = this.mainTimeline.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const percent = Math.max(0, Math.min(1, x / rect.width));
                    return percent * this.state.duration;
                };
                
                const handleDrag = (e) => {
                    if (!this.state.isDragging || !this.state.duration) return;
                    
                    const now = performance.now();
                    if (now - lastDragTime < dragThrottle) return;
                    lastDragTime = now;
                    
                    const time = getTimeFromPosition(e);
                    this.seekTo(time, 'timeline');
                    e.preventDefault();
                };
                
                // Mouse events
                this.mainTimeline.addEventListener('mousedown', (e) => {
                    if (!this.state.duration) return;
                    this.state.isDragging = true;
                    const time = getTimeFromPosition(e);
                    this.seekTo(time, 'timeline');
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', handleDrag);
                document.addEventListener('mouseup', () => {
                    if (this.state.isDragging) {
                        this.state.isDragging = false;
                        this.updatePlayhead(true);
                    }
                });
                
                // Touch events
                let lastTouchTime = 0;
                
                this.mainTimeline.addEventListener('touchstart', (e) => {
                    if (!this.state.duration) return;
                    this.state.isDragging = true;
                    const touch = e.touches[0];
                    const rect = this.mainTimeline.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const percent = Math.max(0, Math.min(1, x / rect.width));
                    const time = percent * this.state.duration;
                    this.seekTo(time, 'timeline');
                    e.preventDefault();
                }, { passive: false });
                
                document.addEventListener('touchmove', (e) => {
                    if (!this.state.isDragging || !this.state.duration) return;
                    
                    const now = performance.now();
                    if (now - lastTouchTime < dragThrottle) return;
                    lastTouchTime = now;
                    
                    const touch = e.touches[0];
                    const rect = this.mainTimeline.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const percent = Math.max(0, Math.min(1, x / rect.width));
                    const time = percent * this.state.duration;
                    this.seekTo(time, 'timeline');
                    e.preventDefault();
                }, { passive: false });
                
                document.addEventListener('touchend', () => {
                    if (this.state.isDragging) {
                        this.state.isDragging = false;
                        this.updatePlayhead(true);
                    }
                });
            }

// ============================================ 
// PART 2: VideoTimelineController Methods (Waveform, Selection, Playback) 
// ============================================ 

// Add to VideoTimelineController class from Part 1:

// ============================================ 
// WAVEFORM MANAGEMENT 
// ============================================ 
initWaveform(waveformData = null) {
    if (this.wavesurfer) {
        this.wavesurfer.destroy();
        this.wavesurfer = null;
    }
    
    const waveformContainer = document.getElementById('waveform-scroll-container');
    const loadingIndicator = document.getElementById('loading-indicator');
    const waveformMessage = document.getElementById('waveform-message');
    
    loadingIndicator.style.display = 'block';
    waveformMessage.style.display = 'none';
    
    this.wavesurfer = WaveSurfer.create({
        container: '#waveform',
        waveColor: '#2a5298',
        progressColor: '#1e3c72',
        backend: 'MediaElement',
        media: this.video,
        height: 128,
        responsive: true,
        interact: true,
        dragToSeek: false,
        cursorColor: '#ff0000',
        cursorWidth: 2,
        partialRender: true,
        pixelRatio: 1,
        fillParent: true,
        scrollParent: false,
        plugins: [
            WaveSurfer.regions.create({
                regionsMinLength: 0.1,
                dragSelection: false
            })
        ]
    });
    
    this.wavesurfer.on('ready', () => {
        this.state.isWaveformReady = true;
        loadingIndicator.style.display = 'none';
        waveformContainer.style.display = 'block';
        
        // Zoom to show ~5 seconds
        const pxPerSec = waveformContainer.clientWidth / 5;
        this.wavesurfer.zoom(pxPerSec);
        
        this.setupWaveformRegion();
        
        // Render any existing markers on the waveform
        if (window.app) {
            window.app.renderWaveformMarkerRegions();
        }
        
        // Dispatch custom event
        document.dispatchEvent(new CustomEvent('waveform-ready'));
        
        waveformMessage.textContent = 'Waveform loaded successfully! ðŸŽµ Click anywhere to seek.';
        waveformMessage.style.color = '#28a745';
        waveformMessage.style.display = 'block';
        setTimeout(() => { waveformMessage.style.display = 'none'; }, 6000);
    });
    
    this.wavesurfer.on('seeking', (time) => {
        if (Math.abs(this.video.currentTime - time) > 0.01) {
            this.seekTo(time, 'waveform');
        }
    });
    
    this.wavesurfer.on('audioprocess', () => {
        if (!this.video.paused) {
            this.updatePlayhead();
        }
    });
    
    this.wavesurfer.on('error', (err) => {
        console.error('WaveSurfer error:', err);
        this.state.isWaveformReady = false;
        loadingIndicator.style.display = 'none';
        waveformMessage.textContent = `Failed: ${err}`;
        waveformMessage.style.color = '#e74c3c';
        waveformMessage.style.display = 'block';
    });
    
    if (waveformData) {
        this.loadPeaksData(waveformData);
    }
}

loadPeaksData(jsonData) {
    if (!jsonData || !jsonData.data || !jsonData.bits) {
        console.error('Invalid waveform data');
        return;
    }
    
    setTimeout(() => {
        try {
            const bits = jsonData.bits;
            const divisor = 2 ** (bits - 1);
            const data = Array.isArray(jsonData.data[0]) ? jsonData.data[0] : jsonData.data;
            const peaks = data.map(p => p / divisor);
            
            this.wavesurfer.load(this.video, peaks);
        } catch (err) {
            console.error('Error loading peaks:', err);
        }
    }, 100);
}

// ============================================ 
// SELECTION MANAGEMENT (FIXED) 
// ============================================ 
setSelection(start, end) {
    if (start === undefined || end === undefined || start > end) return;
    
    this.state.selection = { start, end };
    this.updateSelection();
    
    if (this.selectionRegion) {
        this.selectionRegion.update({ start, end });
    }
}

updateSelection() {
    if (!this.state.duration) return;
    
    const { start, end } = this.state.selection;
    const startPercent = (start / this.state.duration) * 100;
    const endPercent = (end / this.state.duration) * 100;
    
    this.mainTimelineSelection.style.left = `${startPercent}%`;
    this.mainTimelineSelection.style.width = `${endPercent - startPercent}%`;
    
    this.updateTimeDisplaysCached(this.video.currentTime, true);
}

setupWaveformRegion() {
    if (!this.wavesurfer) return;
    
    // FIXED: Don't clear all regions - only update/create selection region
    if (this.selectionRegion) {
        this.selectionRegion.update({
            start: this.state.selection.start,
            end: this.state.selection.end
        });
    } else {
        this.selectionRegion = this.wavesurfer.regions.add({
            start: this.state.selection.start,
            end: this.state.selection.end,
            color: 'rgba(33, 150, 243, 0.2)',
            drag: true,
            resize: true,
            attributes: {
                isMarker: false,
                isSelection: true
            }
        });
        
        this.selectionRegion.on('update-end', () => {
            this.setSelection(this.selectionRegion.start, this.selectionRegion.end);
        });
    }
}

// ============================================ 
// PLAYBACK CONTROL 
// ============================================ 
play() {
    if (this.state.isWaveformReady && this.wavesurfer) {
        this.wavesurfer.play();
    } else {
        this.video.play().catch(e => console.log('Play failed:', e));
    }
    this.startPlayheadAnimation();
}

pause() {
    if (this.state.isWaveformReady && this.wavesurfer) {
        this.wavesurfer.pause();
    } else {
        this.video.pause();
    }
    this.stopPlayheadAnimation();
    this.updatePlayhead(true);
}

playPause() {
    if (this.state.isWaveformReady && this.wavesurfer) {
        this.wavesurfer.playPause();
    } else {
        if (this.video.paused) {
            this.play();
        } else {
            this.pause();
        }
    }
}

stop() {
    this.pause();
    this.seekTo(0);
}

stepFrame(direction) {
    const frameStep = 1 / this.state.frameRate;
    const currentTime = this.video.currentTime;
    const newTime = direction > 0 
        ? Math.min(this.state.duration, (Math.round(currentTime * this.state.frameRate) + 1) / this.state.frameRate)
        : Math.max(0, (Math.round(currentTime * this.state.frameRate) - 1) / this.state.frameRate);
    this.seekTo(newTime);
    this.updatePlayhead(true);
    this.updateTimeDisplaysCached(newTime);
}

// ============================================ 
// TIME UPDATE HANDLING 
// ============================================ 
handleTimeUpdate() {
    // Handle looping
    if (this.state.isLooping) {
        const currentTime = this.video.currentTime;
        if (currentTime >= this.state.selection.end) {
            this.seekTo(this.state.selection.start);
            this.play();
            return;
        }
    }
    
    if (!this.video.paused && !this.state.isSeeking && !this.state.isDragging) {
        this.updatePlayhead();
    }
    
    if (window.updateCurrentSubtitle) {
        window.updateCurrentSubtitle();
    }
}

// ============================================ 
// TIME DISPLAY UTILITIES WITH CACHING 
// ============================================ 
toSMPTE(seconds) {
    if (isNaN(seconds) || isNaN(this.state.frameRate)) {
        return "00:00:00:00";
    }
    
    const cacheKey = `${seconds.toFixed(3)}_${this.state.frameRate}`;
    if (this.smpteCache.has(cacheKey)) {
        return this.smpteCache.get(cacheKey);
    }
    
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    const frames = Math.floor((seconds * this.state.frameRate) % this.state.frameRate);
    
    const result = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}:${frames.toString().padStart(2, '0')}`;
    
    if (this.smpteCache.size > 1000) {
        this.smpteCache.clear();
    }
    this.smpteCache.set(cacheKey, result);
    
    return result;
}

updateTimeDisplaysCached(forceTime = null, forceUpdate = false) {
    if (!this.video.duration || !isFinite(this.video.duration)) return;
    
    const currentTime = forceTime !== null ? forceTime : this.video.currentTime;
    
    // CHANGED: Check forceUpdate flag first
    if (!forceUpdate && Math.abs(currentTime - this.lastCacheTime) < 0.01) {
        return;
    }
    this.lastCacheTime = currentTime;
    
    const duration = this.video.duration;
    const { start, end } = this.state.selection;
    const selectionDuration = end - start;
    
    this.currentTimeDisplay.textContent = this.toSMPTE(currentTime);
    this.durationTimeDisplay.textContent = this.toSMPTE(duration);
    this.selectionTimeDisplay.textContent = 
        `IN: ${this.toSMPTE(start)} - OUT: ${this.toSMPTE(end)}`;
    this.selectionDurationDisplay.textContent = 
        `Duration: ${this.toSMPTE(selectionDuration)}`;
    
	// Timeline scale removed - no longer needed
}

updateTimeDisplays() {
    this.updateTimeDisplaysCached();
}

// ============================================ 
// CLEANUP 
// ============================================ 
destroy() {
    this.stopPlayheadAnimation();
    
    if (this.wavesurfer) {
        this.wavesurfer.destroy();
        this.wavesurfer = null;
    }
    
    this.video.removeEventListener('timeupdate', this.handleTimeUpdate);
}
}

// ============================================ 
// PART 3: APPLICATION CONTROLLER CLASS 
// ============================================ 

class AppController {
    constructor() {
        this.initDOMElements();
        
        this.state = {
            originalFileName: '',
            originalFilePath: '',
            currentVideoUrl: null,
            subtitles: [],
            currentSubtitleIndex: -1,
            subtitleFormat: 'srt',
            wordTimings: [],
            searchMatches: [],
            currentMatchIndex: -1,
            audioContext: null,
            audioInfo: { samplerate: null, channelcount: null },
            importedWaveformData: null,
            editingMarkerIndex: -1
        };
        
        this.videoController = null;
        this.init();
    }
    
    initDOMElements() {
        // Video elements
        this.video = document.getElementById('my_video');
        this.fileInput = document.getElementById('video-upload');
        this.jsonInput = document.getElementById('json-upload');
        this.playPauseBtn = document.getElementById('play-pause');
        this.stopBtn = document.getElementById('stop');
        this.frameBackBtn = document.getElementById('frame-back');
        this.frameForwardBtn = document.getElementById('frame-forward');
        this.framerateSelect = document.getElementById('framerate-select');
        this.currentTimeDisplay = document.getElementById('current-time-value');
        this.durationTimeDisplay = document.getElementById('duration-time-value');
        this.selectionTimeDisplay = document.getElementById('selection-time');
        this.selectionDurationDisplay = document.getElementById('selection-duration');
        this.resetZoomBtn = document.getElementById('reset-zoom');
		this.prevMarkerBtn = document.getElementById('prev-marker-btn');
		this.nextMarkerBtn = document.getElementById('next-marker-btn');			
        this.jumpToInBtn = document.getElementById('jump-to-in');
        this.jumpToOutBtn = document.getElementById('jump-to-out');
        this.markersList = document.getElementById('markers-list');
        this.addMarkerBtn = document.getElementById('add-marker');
        this.saveJsonBtn = document.getElementById('save-json');
		this.editActiveMarkerBtn = document.getElementById('edit-active-marker'); // ADD THIS LINE
        this.dropZone = document.getElementById('file-drop-zone');
        this.playheadPositionSelect = document.getElementById('playhead-position');
        this.customDurationInput = document.getElementById('custom-duration-input');
        this.framesInput = document.getElementById('frames-input');
        this.minutesInput = document.getElementById('minutes-input');
        this.secondsInput = document.getElementById('seconds-input');
        this.setPreciseRangeBtn = document.getElementById('set-precise-range'); // NEW: SET button
        this.customPathInput = document.getElementById('custom-path');
        this.savePathBtn = document.getElementById('save-path');
        this.savedPathsSelect = document.getElementById('saved-paths');
        this.detectedFpsDisplay = document.getElementById('detected-fps');
        this.markerSearchInput = document.getElementById('marker-search');
        this.markerSearchClearBtn = document.getElementById('marker-search-clear-btn');
        
        // Main timeline elements
        this.mainTimeline = document.getElementById('main-timeline');
        this.mainTimelineSelection = document.getElementById('main-timeline-selection');
        this.mainTimelinePlayhead = document.getElementById('main-timeline-playhead');
        
        // Subtitle & Search elements
        this.subtitleFileInput = document.getElementById('subtitle-file');
        this.currentSubtitleDisplay = document.getElementById('current-subtitle');
        this.searchBox = document.getElementById('search-box');
        this.searchClearBtn = document.getElementById('search-clear-btn');
        this.subtitleList = document.getElementById('subtitle-list');
        this.prevMatchButton = document.getElementById('prev-match');
        this.nextMatchButton = document.getElementById('next-match');
        this.searchNavigation = document.getElementById('search-navigation');
        
        this.repeatBtn = document.getElementById('repeat-play');
        this.applySearchPaddingCheckbox = document.getElementById('apply-search-padding');
        this.paddingInfoText = document.getElementById('padding-info');
    }
    
    init() {
        this.videoController = new VideoTimelineController({
            video: this.video,
            mainTimeline: this.mainTimeline,
            mainTimelineSelection: this.mainTimelineSelection,
            mainTimelinePlayhead: this.mainTimelinePlayhead,
            currentTimeDisplay: this.currentTimeDisplay,
            durationTimeDisplay: this.durationTimeDisplay,
            selectionTimeDisplay: this.selectionTimeDisplay,
            selectionDurationDisplay: this.selectionDurationDisplay,
            detectedFpsDisplay: this.detectedFpsDisplay,
            framerateSelect: this.framerateSelect
        });
        
        this.setupEventListeners();
        this.updatePathDropdown();
        this.updateFramesInputMax();
        this.setupGlobalFunctions();
    }
    
    setupEventListeners() {
        // Playback controls
        this.playPauseBtn.addEventListener('click', () => this.videoController.playPause());
        this.stopBtn.addEventListener('click', () => this.videoController.stop());
        this.frameBackBtn.addEventListener('click', () => this.videoController.stepFrame(-1));
        this.frameForwardBtn.addEventListener('click', () => this.videoController.stepFrame(1));
        
        // Repeat button
        this.repeatBtn.addEventListener('click', () => {
            this.videoController.state.isLooping = !this.videoController.state.isLooping;
            this.repeatBtn.classList.toggle('active', this.videoController.state.isLooping);
            if (this.videoController.state.isLooping && this.video.paused) {
                this.videoController.seekTo(this.videoController.state.selection.start);
                this.videoController.play();
            }
        });
        
        // Selection controls
        document.getElementById('set-in-point').addEventListener('click', () => this.setInPoint());
        document.getElementById('set-out-point').addEventListener('click', () => this.setOutPoint());
        
        // Custom duration inputs
        // SET button for precise range duration (replaces automatic updating)
        this.setPreciseRangeBtn.addEventListener('click', () => this.updateSelectionFromPlayhead());
        
        // Reset zoom
        this.resetZoomBtn.addEventListener('click', () => {
            if (this.video.duration) {
                this.videoController.setSelection(0, this.video.duration);
                this.videoController.seekTo(0);
            }
        });
		
	// ============================================
	// MARKER NAVIGATION
	// ============================================
        // Jump to IN/OUT points
        this.jumpToInBtn.addEventListener('click', () => {
            this.videoController.seekTo(this.videoController.state.selection.start);
        });
        
        this.jumpToOutBtn.addEventListener('click', () => {
            this.videoController.seekTo(this.videoController.state.selection.end);
        });
        
        // File inputs
        this.fileInput.addEventListener('change', e => {
            if (e.target.files[0]) this.loadVideo(e.target.files[0]);
            e.target.blur();
        });
        this.jsonInput.addEventListener('change', e => {
            if (e.target.files[0]) this.handleJSONImport(e.target.files[0]);
            e.target.blur();
        });
        this.subtitleFileInput.addEventListener('change', e => {
            this.handleSubtitleSelect(e);
            e.target.blur();
        });
        
        // Marker controls
        this.addMarkerBtn.addEventListener('click', () => this.addMarker());
        this.saveJsonBtn.addEventListener('click', () => this.saveJSON());
		// Add this after the addMarkerBtn event listener:
		this.editActiveMarkerBtn.addEventListener('click', () => {
			const activeIndex = this.videoController.state.activeMarkerIndex;
			if (activeIndex !== -1 && this.videoController.state.markers[activeIndex]) {
				// Switch to markers tab
				document.getElementById('markers-tab').click();
				
				// Find the marker element
				const markerElement = document.querySelector(`.marker-item[data-index="${activeIndex}"]`);
				if (markerElement) {
					// Call edit function
					this.editMarkerText(activeIndex, markerElement);
					
					// Scroll to marker
					setTimeout(() => {
						markerElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
					}, 100);
				}
			}
		});
		
		// Add after the existing marker controls:
		// Region navigation
		this.prevMarkerBtn.addEventListener('click', () => this.jumpToPreviousMarker());
		this.nextMarkerBtn.addEventListener('click', () => this.jumpToNextMarker());		

        // Search functionality
        this.searchBox.addEventListener('input', () => {
            this.updateSearchClearButton();
            this.debounce(this.filterSubtitles.bind(this), 300)();
        });
        this.searchClearBtn.addEventListener('click', () => this.clearSearch());
        this.prevMatchButton.addEventListener('click', () => this.navigateToPreviousMatch());
        this.nextMatchButton.addEventListener('click', () => this.navigateToNextMatch());
        
        // Marker search
        this.markerSearchInput.addEventListener('input', () => {
            this.updateMarkerSearchClearButton();
            this.updateMarkersList(this.markerSearchInput.value);
        });
        this.markerSearchClearBtn.addEventListener('click', () => this.clearMarkerSearch());
        
        // Search padding
        this.applySearchPaddingCheckbox.addEventListener('change', () => {
            this.paddingInfoText.style.display = this.applySearchPaddingCheckbox.checked ? 'inline' : 'none';
        });
        
        // Add search markers button
        const addSearchMarkersBtn = document.getElementById('add-search-markers');
        if (addSearchMarkersBtn) {
            addSearchMarkersBtn.addEventListener('click', () => this.addSearchResultsAsMarkers());
        }
        
        // Path management
        this.savePathBtn.addEventListener('click', () => {
            const path = this.customPathInput.value.trim();
            if (path) this.saveCustomPath(path);
        });
        
        this.savedPathsSelect.addEventListener('change', function() {
            if (this.value) this.customPathInput.value = this.value;
        }.bind(this));
        
        // Drag and drop
        this.setupDragAndDrop();
        
        // Keyboard shortcuts
        this.setupKeyboardShortcuts();
        
        // FIXED: Frame rate change - moved out event listeners that were incorrectly nested
        this.framerateSelect.addEventListener('change', () => {
            if (this.videoController && this.videoController.smpteCache) {
                this.videoController.smpteCache.clear();
            }
            this.updateFramesInputMax();
            this.updateMarkersList();
        });
        
    }
    
// ============================================ 
// FINAL PART: AppController Methods (Markers, Subtitles, Missing Methods) 
// Add these to AppController class from Part 3 
// ============================================ 

// ============================================ 
// DRAG AND DROP 
// ============================================ 
setupDragAndDrop() {
    const handleDragOver = (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.dropZone.classList.add('drag-over');
    };
    
    const handleDragLeave = (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.dropZone.classList.remove('drag-over');
    };
    
    const handleDrop = (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.dropZone.classList.remove('drag-over');
        
        const files = Array.from(e.dataTransfer.files);
        const videoFiles = files.filter(f => f.type.startsWith('video/'));
        const subtitleFiles = files.filter(f => f.name.endsWith('.srt') || f.name.endsWith('.vtt') || f.name.endsWith('.txt'));
        const jsonFiles = files.filter(f => f.name.endsWith('.json'));
        
        if (videoFiles.length > 0) this.loadVideo(videoFiles[0]);
        if (jsonFiles.length > 0) this.handleJSONImport(jsonFiles[0]);
        if (subtitleFiles.length > 0) this.handleSubtitleFile(subtitleFiles[0]);
    };
    
    this.dropZone.addEventListener('dragover', handleDragOver);
    this.dropZone.addEventListener('dragleave', handleDragLeave);
    this.dropZone.addEventListener('drop', handleDrop);
    
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        document.body.addEventListener(eventName, e => {
            e.preventDefault();
            e.stopPropagation();
        });
    });
}

// ============================================ 
// KEYBOARD SHORTCUTS 
// ============================================ 
setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || 
            e.target.tagName === 'SELECT' || 
            e.target.tagName === 'TEXTAREA') {
            return;
        }
        
        if (e.key === 'Enter' && e.target.tagName === 'BUTTON') {
            e.preventDefault();
            return;
        }
        
        switch(e.code) {
            case 'Space':
                e.preventDefault();
                e.stopPropagation();
                if (document.activeElement && document.activeElement.tagName === 'BUTTON') {
                    document.activeElement.blur();
                }
                this.videoController.playPause();
                break;
                
            case 'ArrowLeft':
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    this.videoController.stepFrame(-1);
                }
                break;
                
            case 'ArrowRight':
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    this.videoController.stepFrame(1);
                }
                break;
                
            case 'KeyI':
                e.preventDefault();
                this.setInPoint();
                break;
                
            case 'KeyO':
                e.preventDefault();
                this.setOutPoint();
                break;
				
			case 'BracketLeft':
				e.preventDefault();
				this.addMarker();
				break;
				
			case 'BracketRight':  // "]" key to apply duration settings
				e.preventDefault();
				this.updateSelectionFromPlayhead();
				break;				
                
            case 'KeyX':
                e.preventDefault();
                if (this.video.duration) {
                    this.videoController.setSelection(0, this.video.duration);
                    this.videoController.seekTo(0);
                }
                break;
                
            case 'KeyQ':
                e.preventDefault();
                this.videoController.seekTo(this.videoController.state.selection.start);
                break;
                
            case 'KeyW':
                e.preventDefault();
                this.videoController.seekTo(this.videoController.state.selection.end);
                break;
			// Add these cases to the switch statement:
			case 'KeyQ':
				if (e.shiftKey) {
					e.preventDefault();
					this.jumpToPreviousMarker();
				} else {
					e.preventDefault();
					this.videoController.seekTo(this.videoController.state.selection.start);
				}
				break;
				
			case 'KeyW':
				if (e.shiftKey) {
					e.preventDefault();
					this.jumpToNextMarker();
				} else {
					e.preventDefault();
					this.videoController.seekTo(this.videoController.state.selection.end);
				}
				break;				
				
            case 'KeyT':
                e.preventDefault();
                const tabs = document.querySelectorAll('[data-bs-toggle="tab"]');
                const activeTab = document.querySelector('.nav-link.active');
                const activeIndex = Array.from(tabs).indexOf(activeTab);
                const nextIndex = (activeIndex + 1) % tabs.length;
                tabs[nextIndex].click();
                break;
                
            case 'Escape':
                e.preventDefault();
                this.exitMarkerEditMode();
                if (window.getSelection) {
                    window.getSelection().removeAllRanges();
                }
                document.querySelectorAll('.marker-edit-form').forEach(form => form.remove());
                break;
        }
    });
}

setupGlobalFunctions() {
    window.seekTo = (time) => this.videoController.seekTo(time);
    window.setSelectionRange = (start, end) => this.videoController.setSelection(start, end);
    window.loadMarker = (index) => this.loadMarker(index);
    window.addMarker = () => this.addMarker();
    window.removeMarker = (index) => this.removeMarker(index);
    window.updateCurrentSubtitle = () => this.updateCurrentSubtitle();
}

// ============================================ 
// VIDEO LOADING 
// ============================================ 
loadVideo(file) {
    if (file && file.type.startsWith('video/')) {
        if (this.state.currentVideoUrl) {
            URL.revokeObjectURL(this.state.currentVideoUrl);
        }
        
        this.state.originalFileName = file.name;
        this.state.originalFilePath = file.path || file.webkitRelativePath || `C:/Videos/${file.name}`;
        
        this.state.currentVideoUrl = URL.createObjectURL(file);
        this.video.src = this.state.currentVideoUrl;
        
        this.state.audioInfo = { samplerate: null, channelcount: null };
        this.currentSubtitleDisplay.textContent = '';
        this.resetWaveform();
        
        this.video.onerror = () => {
            console.error('Error loading video:', this.video.error);
            alert('Error loading video. Please try another file.');
        };
    } else {
        alert('Please upload a valid video file.');
    }
}

// ============================================ 
// SELECTION MANAGEMENT 
// ============================================ 
setInPoint() {
    if (!this.video.duration) return;
    const currentTime = this.video.currentTime;
    const { end } = this.videoController.state.selection;
    if (currentTime < end) {
        this.videoController.setSelection(currentTime, end);
    } else {
        this.videoController.setSelection(currentTime, currentTime);
    }
}

setOutPoint() {
    if (!this.video.duration) return;
    const currentTime = this.video.currentTime;
    const { start } = this.videoController.state.selection;
    if (currentTime > start) {
        this.videoController.setSelection(start, currentTime);
    } else {
        this.videoController.setSelection(currentTime, currentTime);
    }
}

updateSelectionFromPlayhead() {
    if (!this.video.duration) return;
    
    const minutes = parseInt(this.minutesInput.value) || 0;
    const seconds = parseInt(this.secondsInput.value) || 0;
    const frames = parseInt(this.framesInput.value) || 0;
    const frameRate = this.videoController.state.frameRate;
    const newDuration = minutes * 60 + seconds + (frames / frameRate);
    
    let newStart, newEnd;
    const currentTime = this.video.currentTime;
    
    switch (this.playheadPositionSelect.value) {
        case 'in':
            newStart = currentTime;
            newEnd = Math.min(this.video.duration, newStart + newDuration);
            break;
        case 'out':
            newEnd = currentTime;
            newStart = Math.max(0, newEnd - newDuration);
            break;
        case 'mid':
            const halfDuration = newDuration / 2;
            newStart = Math.max(0, currentTime - halfDuration);
            newEnd = Math.min(this.video.duration, currentTime + halfDuration);
            break;
    }
    
    this.videoController.setSelection(newStart, newEnd);
}

// ============================================ 
// MARKER MANAGEMENT (FIXED - NO DUPLICATES) 
// ============================================ 
addMarker() {
    if (!this.video.duration) return;
    
    const { start, end } = this.videoController.state.selection;
    const frameRate = this.videoController.state.frameRate;
    
    let subtitleText = "";
    let subtitleItems = [];
    
    if (this.state.subtitleFormat === "vtt" && this.state.wordTimings.length > 0) {
        const wordsInRange = this.state.wordTimings.filter(word => 
            word.startTime >= start && word.endTime <= end
        );
        
        if (wordsInRange.length > 0) {
            subtitleText = wordsInRange.map(word => word.text).join(' ');
            subtitleItems.push({
                text: subtitleText,
            });
        }
    } else {
        const overlappingSubtitles = this.state.subtitles.filter(subtitle => 
            (subtitle.startTime < end && subtitle.endTime > start)
        );
        
        if (overlappingSubtitles.length > 0) {
            subtitleText = overlappingSubtitles.map(sub => sub.text).join(" ");
            subtitleItems.push({
                text: subtitleText,
                start: Math.round(start * frameRate),
                end: Math.round(end * frameRate)
            });
        }
    }
    
    const newMarker = {
        start: start,
        end: end,
        duration: end - start,
        comments: subtitleItems
    };
    
	// STEP 1: Add marker to array
	this.videoController.state.markers.push(newMarker);

	// STEP 2: Sort markers by start time (this also re-renders everything)
	this.sortMarkers();

	// STEP 3: Find the new index of our marker after sorting (by object reference)
	const newMarkerIndex = this.videoController.state.markers.indexOf(newMarker);
	this.videoController.state.activeMarkerIndex = newMarkerIndex;
}

// ============================================
// MARKER NAVIGATION
// ============================================
jumpToNextMarker() {
    if (!this.videoController.state.markers.length) return;
    
    const currentTime = this.video.currentTime;
    const markers = this.videoController.state.markers;
    
    // Find first marker that starts after current time (with small buffer to avoid current)
    let nextMarker = markers.find(m => m.start > currentTime + 0.1);
    
    if (!nextMarker) {
        // No marker after current time, wrap to first
        nextMarker = markers[0];
    }
    
    if (nextMarker) {
        const index = markers.indexOf(nextMarker);
        this.loadMarker(index);
    }
}

jumpToPreviousMarker() {
    if (!this.videoController.state.markers.length) return;
    
    const currentTime = this.video.currentTime;
    const markers = this.videoController.state.markers;
    
    // Find last marker that starts before current time (with buffer)
    let prevMarker = null;
    for (let i = markers.length - 1; i >= 0; i--) {
        if (markers[i].start < currentTime - 0.1) {
            prevMarker = markers[i];
            break;
        }
    }
    
    if (!prevMarker) {
        // No marker before current time, wrap to last
        prevMarker = markers[markers.length - 1];
    }
    
    if (prevMarker) {
        const index = markers.indexOf(prevMarker);
        this.loadMarker(index);
    }
}

// MARKER MANAGEMENT (FIXED - NO DUPLICATES)

loadMarker(index) {
    if (!this.video.duration || !this.videoController.state.markers[index]) return;
    
    const marker = this.videoController.state.markers[index];
    this.videoController.setSelection(marker.start, marker.end);
    if (this.videoController.selectionRegion) {
        this.videoController.selectionRegion.update({
            start: marker.start,
            end: marker.end
        });
    }
    this.videoController.seekTo(marker.start);
    this.videoController.state.activeMarkerIndex = index;
    // ADD THIS: Enable edit button
    if (this.editActiveMarkerBtn) {
        this.editActiveMarkerBtn.disabled = false;
    }	
	
    this.updateMarkersList();
    this.renderTimelineMarkers();
    this.highlightWaveformMarkerRegion(index);
}

removeMarker(index) {
    const { markers, activeMarkerIndex } = this.videoController.state;
    
    if (index === activeMarkerIndex) {
        this.videoController.state.activeMarkerIndex = -1;
    } else if (index < activeMarkerIndex) {
        this.videoController.state.activeMarkerIndex--;
    }
    
    markers.splice(index, 1);
    this.updateEditMarkerButtonState(); // ADD THIS LINE	
    this.updateMarkersList();
    this.renderTimelineMarkers();
    this.renderWaveformMarkerRegions();
}

// ============================================ 
// CRITICAL MISSING METHODS + MARKER RENDERING 
// ============================================ 

// ============================================ 
// MISSING METHOD: sortMarkers (FIXED) 
// ============================================ 
sortMarkers() {
    this.videoController.state.markers.sort((a, b) => a.start - b.start);
    this.updateMarkersList();
    this.renderTimelineMarkers();
    this.renderWaveformMarkerRegions();
}

// ============================================ 
// MISSING METHOD: exitMarkerEditMode (FIXED) 
// ============================================ 
exitMarkerEditMode() {
    this.state.editingMarkerIndex = -1;
    
    document.querySelectorAll('.marker-item.editing').forEach(item => {
        item.classList.remove('editing');
    });
    
    if (this.videoController.wavesurfer && this.videoController.wavesurfer.regions) {
        const regions = this.videoController.wavesurfer.regions.list;
        Object.values(regions).forEach(region => {
            if (region.element) {
                region.element.classList.remove('editing-marker');
            }
        });
    }
    
    document.querySelectorAll('.marker-edit-form').forEach(form => form.remove());
}

// Add this new method in the AppController class (around line 2400):
updateEditMarkerButtonState() {
    if (!this.editActiveMarkerBtn) return;
    
    const hasActiveMarker = this.videoController.state.activeMarkerIndex !== -1 &&
                           this.videoController.state.markers[this.videoController.state.activeMarkerIndex];
    
    this.editActiveMarkerBtn.disabled = !hasActiveMarker;
}

// ============================================ 
// UPDATE MARKERS LIST (FIXED) 
// ============================================ 
updateMarkersList(searchTerm = '') {
    const { markers, activeMarkerIndex, frameRate } = this.videoController.state;
    const lowerCaseSearchTerm = searchTerm.toLowerCase();
    
    const filteredMarkers = markers
        .map((marker, index) => ({ marker, originalIndex: index }))
        .filter(({ marker }) => {
            if (!lowerCaseSearchTerm) return true;
            const commentObj = marker.comments && marker.comments.length > 0 ? marker.comments[0] : null;
            const displayText = commentObj ? commentObj.text : "";
            return displayText.toLowerCase().includes(lowerCaseSearchTerm);
        });

    this.markersList.innerHTML = markers.length ? '<h5 class="mt-3 mb-2">Markers:</h5>' : '';
    
    filteredMarkers.forEach(({ marker, originalIndex }) => {
        const div = document.createElement('div');
        div.className = 'marker-item';
        div.setAttribute('data-index', originalIndex);
        
        if (originalIndex === this.state.editingMarkerIndex) {
            div.classList.add('editing');
        }
        
        if (originalIndex === activeMarkerIndex) {
            div.classList.add('active');
        }
        
        const commentObj = marker.comments && marker.comments.length > 0 ? marker.comments[0] : null;
        const displayText = commentObj ? commentObj.text : "";
        
        const headerDiv = document.createElement('div');
        headerDiv.className = 'marker-header';
        headerDiv.innerHTML = `
            <span class="marker-label">Marker ${originalIndex + 1}: ${this.videoController.toSMPTE(marker.start)} - ${this.videoController.toSMPTE(marker.end)} (${this.videoController.toSMPTE(marker.duration)})</span>
            <div class="marker-actions">
                <button class="btn btn-sm btn-primary me-1 load-marker" title="Load this marker">Load</button>
                <button class="btn btn-sm btn-info me-1 edit-marker" title="Edit comment text">Edit</button>
                <button class="btn btn-sm btn-danger remove-marker" title="Remove this marker">X</button>
            </div>
        `;
        div.appendChild(headerDiv);
        
        if (displayText) {
            const commentDiv = document.createElement('div');
            commentDiv.className = 'marker-comment';
            commentDiv.textContent = displayText;
            div.appendChild(commentDiv);
        }
        
        headerDiv.querySelector('.marker-label').addEventListener('click', () => {
            this.loadMarker(originalIndex);
        });
        
        headerDiv.querySelector('.load-marker').addEventListener('click', () => {
            this.loadMarker(originalIndex);
        });
        
        headerDiv.querySelector('.edit-marker').addEventListener('click', () => {
            this.editMarkerText(originalIndex, div);
        });
        
        headerDiv.querySelector('.remove-marker').addEventListener('click', () => {
            this.removeMarker(originalIndex);
        });
        
        this.markersList.appendChild(div);
    });
}

// ============================================ 
// RENDER TIMELINE MARKERS (FIXED) 
// ============================================ 
renderTimelineMarkers() {
    const existingMarkers = this.mainTimeline.querySelectorAll('.timeline-marker-region');
    existingMarkers.forEach(el => el.remove());
    
    if (!this.video.duration) return;
    
    this.videoController.state.markers.forEach((marker, index) => {
        const startPercent = (marker.start / this.video.duration) * 100;
        const endPercent = (marker.end / this.video.duration) * 100;
        const widthPercent = endPercent - startPercent;
        
        const markerRegion = document.createElement('div');
        markerRegion.className = 'timeline-marker-region';
        markerRegion.dataset.markerIndex = index;
        
        markerRegion.style.left = `${startPercent}%`;
        markerRegion.style.width = `${widthPercent}%`;
        
        if (index === this.videoController.state.activeMarkerIndex) {
            markerRegion.classList.add('active');
        }
        
        const markerNumber = index + 1;
        const tooltipText = `Marker ${markerNumber}: ${this.videoController.toSMPTE(marker.start)} - ${this.videoController.toSMPTE(marker.end)}`;
        markerRegion.title = tooltipText;
        
        markerRegion.addEventListener('click', (e) => {
            e.stopPropagation();
            this.loadMarker(index);
        });
        
        markerRegion.addEventListener('mouseenter', () => {
            markerRegion.style.opacity = '0.6';
        });
        
        markerRegion.addEventListener('mouseleave', () => {
            markerRegion.style.opacity = '';
        });
        
        this.mainTimeline.appendChild(markerRegion);
    });
}

// ============================================ 
// RENDER WAVEFORM MARKER REGIONS (FIXED - SINGLE DEFINITION) 
// ============================================ 

renderWaveformMarkerRegions() {
    if (!this.videoController.state.isWaveformReady || !this.videoController.wavesurfer) {
        return;
    }
    
    if (this.videoController.wavesurfer.regions) {
        const regions = this.videoController.wavesurfer.regions.list;
        Object.keys(regions).forEach(id => {
            const region = regions[id];
            if (region && region.attributes && region.attributes.isMarker === true) {
                region.remove();
            }
        });
    }
    
    this.videoController.state.markers.forEach((marker, index) => {
        // Get comment text
        const commentText = marker.comments && marker.comments.length > 0 
            ? marker.comments[0].text 
            : '';
        
        // Truncate for label (show first 40 chars)
        const labelText = commentText.length > 40 
            ? commentText.substring(0, 40) + '...' 
            : commentText;
        
        const region = this.videoController.wavesurfer.regions.add({
            start: marker.start,
            end: marker.end,
            color: 'rgba(255, 0, 0, 0.2)',
            drag: true,
            resize: true,
            attributes: {
                isMarker: true,
                markerIndex: index,
                markerRef: marker,
                label: `Marker ${index + 1}`,
                commentText: commentText, // Store full text
                commentLabel: labelText   // Store truncated text
            }
        });
        
        // CRITICAL FIX: Delay adding label to ensure element exists
        const addLabel = () => {
            if (region.element && labelText) {
                // Remove any existing labels first
                const existingLabel = region.element.querySelector('.wavesurfer-region-label');
                if (existingLabel) {
                    existingLabel.remove();
                }
                
                // Create label element
                const labelElement = document.createElement('div');
                labelElement.className = 'wavesurfer-region-label';
                labelElement.textContent = labelText;
                labelElement.title = commentText; // Full text on hover
                
                // Append to region element
                region.element.appendChild(labelElement);
                
                // Store update function on the region object
                region.updateLabelStyle = () => {
                    const isActive = this.videoController.state.activeMarkerIndex === index;
                    if (labelElement && labelElement.parentNode) { // Check element still exists
                        labelElement.style.background = isActive 
                            ? 'rgba(255, 215, 0, 0.9)' 
                            : 'rgba(255, 255, 255, 0.85)';
                    }
                };
                
                // Initial style update
                region.updateLabelStyle();
            }
        };
        
        // Try immediately first
        addLabel();
        
        // If element doesn't exist yet, try again after a brief delay
        if (!region.element) {
            setTimeout(addLabel, 10);
            
            // Fallback: try once more after a longer delay
            setTimeout(addLabel, 50);
        }
        
        this.attachRegionEventListeners(region, index, marker);
    });
}

attachRegionEventListeners(region, initialIndex, markerRef) {
 
	region.on('update-end', () => {
		if (!markerRef) return;
		
		// Update marker times
		markerRef.start = region.start;
		markerRef.end = region.end;
		markerRef.duration = region.end - region.start;
		
		// Check if active
		const oldActiveIndex = this.videoController.state.activeMarkerIndex;
		const oldActiveMarker = this.videoController.state.markers[oldActiveIndex];
		const wasActive = (oldActiveMarker === markerRef);
		
		// CRITICAL: Sort markers
		this.sortMarkers();
		
		// Find new index
		const newIndex = this.videoController.state.markers.indexOf(markerRef);
		
		// Keep active if it was before
		if (wasActive && newIndex !== -1) {
			this.videoController.state.activeMarkerIndex = newIndex;
			this.videoController.setSelection(markerRef.start, markerRef.end);
			this.updateMarkersList();
			this.renderTimelineMarkers();
		}
	});
    
	region.on('click', () => {
		const currentIndex = this.videoController.state.markers.indexOf(markerRef);
		if (currentIndex !== -1) {
			this.loadMarker(currentIndex);
			this.highlightWaveformMarkerRegion(currentIndex);
		}
	});
    
}

highlightWaveformMarkerRegion(activeIndex) {
    if (!this.videoController.wavesurfer || !this.videoController.wavesurfer.regions) {
        return;
    }
    
    const regions = this.videoController.wavesurfer.regions.list;
    Object.keys(regions).forEach(id => {
        const region = regions[id];
        if (region.attributes && region.attributes.isMarker) {
            const index = region.attributes.markerIndex;
            if (index === activeIndex) {
                region.update({ color: 'rgba(255, 0, 0, 0.4)' });
                
                // Update label styling if it exists
                if (region.updateLabelStyle) {
                    region.updateLabelStyle();
                }
            } else {
                region.update({ color: 'rgba(255, 0, 0, 0.2)' });
                
                // Update label styling if it exists
                if (region.updateLabelStyle) {
                    region.updateLabelStyle();
                }
            }
        }
    });
}

editMarkerText(index, markerElement) {
    const marker = this.videoController.state.markers[index];
    
    const existingForm = markerElement.querySelector('.marker-edit-form');
    if (existingForm) {
        markerElement.removeChild(existingForm);
        return;
    }
    
    const commentObj = marker.comments && marker.comments.length > 0 ? marker.comments[0] : null;
    const currentText = commentObj ? commentObj.text : "";
    
    const editForm = document.createElement('div');
    editForm.className = 'marker-edit-form mt-2 w-100';
    editForm.innerHTML = `
        <div class="mb-2">
            <label for="marker-text-${index}" class="form-label small">Comment Text</label>
            <textarea class="form-control form-control-sm" id="marker-text-${index}" rows="3" placeholder="Enter comment text...">${currentText}</textarea>
        </div>
        <div class="d-flex justify-content-end">
            <button class="btn btn-sm btn-secondary me-2 cancel-edit">Cancel</button>
            <button class="btn btn-sm btn-primary save-edit">Save Changes</button>
        </div>
    `;
    
    markerElement.appendChild(editForm);
    
    const textArea = document.getElementById(`marker-text-${index}`);
    textArea.focus();
    textArea.setSelectionRange(textArea.value.length, textArea.value.length);
    
    editForm.querySelector('.cancel-edit').addEventListener('click', () => {
        markerElement.removeChild(editForm);
    });
    
	editForm.querySelector('.save-edit').addEventListener('click', () => {
		const newText = document.getElementById(`marker-text-${index}`).value;
		const frameRate = this.videoController.state.frameRate;
		
		if (newText.trim()) {
			if (marker.comments && marker.comments.length > 0) {
				marker.comments[0].text = newText;
			} else {
				marker.comments = [{
					text: newText,
				}];
			}
		} else {
			marker.comments = [];
		}
		
		this.updateMarkersList();
		this.renderTimelineMarkers();
		this.renderWaveformMarkerRegions(); // This will update the label
	});		
}

// ============================================ 
// COMPLETE SUBTITLE HANDLING METHODS 
// Add these to AppController class 
// ============================================ 

handleSubtitleSelect(event) {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            const content = e.target.result;
            
            if (file.name.endsWith('.vtt')) {
                this.state.subtitleFormat = "vtt";
                window.originalVttContent = content;
                this.state.subtitles = this.parseWebVTT(content);
                this.state.wordTimings = this.extractWordTimings(content);
                this.renderTranscript(content);
            } else {
                this.state.subtitleFormat = "srt";
                window.originalSrtContent = content;
                this.state.subtitles = this.parseSRT(content);
                this.renderSubtitleList(this.state.subtitles);
            }
            
            document.getElementById('transcript-tab').click();
        };
        reader.readAsText(file);
    }
}

handleSubtitleFile(file) {
    if (file) {
        const dataTransfer = new DataTransfer();
        dataTransfer.items.add(file);
        this.subtitleFileInput.files = dataTransfer.files;
        const event = new Event('change', { bubbles: true });
        this.subtitleFileInput.dispatchEvent(event);
    }
}

parseSRT(srtContent) {
    const srtItems = [];
    const subtitleBlocks = srtContent.trim().split(/\r?\n\r?\n/);
    
    subtitleBlocks.forEach(block => {
        const lines = block.split(/\r?\n/);
        if (lines.length < 3) return;
        
        const timeRange = lines[1];
        const timeMatch = timeRange.match(/(\d{2}:\d{2}:\d{2},\d{3}) --> (\d{2}:\d{2}:\d{2},\d{3})/);
        
        if (!timeMatch) return;
        
        const startTime = this.timeToSeconds(timeMatch[1]);
        const endTime = this.timeToSeconds(timeMatch[2]);
        const textLines = lines.slice(2);
        const text = textLines.join(' ').trim();
        
        srtItems.push({
            startTime,
            endTime,
            text,
            startTimeString: this.formatTimeForDisplay(startTime)
        });
    });
    
    return srtItems;
}

parseWebVTT(vttContent) {
    const vttItems = [];
    const lines = vttContent.split(/\r?\n/);
    
    let inCue = false;
    let currentCueStart = 0;
    let currentCueEnd = 0;
    let currentCueText = "";
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        
        if (!line || line === 'WEBVTT') continue;
        
        if (line.includes('-->')) {
            if (inCue && currentCueText) {
                vttItems.push({
                    startTime: currentCueStart,
                    endTime: currentCueEnd,
                    text: currentCueText.trim(),
                    startTimeString: this.formatTimeForDisplay(currentCueStart)
                });
            }
            
            inCue = true;
            currentCueText = "";
            const timestamps = line.split('-->').map(t => t.trim());
            currentCueStart = this.parseTimestamp(timestamps[0]);
            currentCueEnd = this.parseTimestamp(timestamps[1]);
            continue;
        }
        
        if (/^\d+$/.test(line)) continue;
        
        if (inCue && line) {
            const cleanLine = line.replace(/<\d\d:\d\d:\d\d\.\d\d\d>|<\/\d\d:\d\d:\d\d\.\d\d\d>/g, '');
            currentCueText += (currentCueText ? " " : "") + cleanLine;
        }
    }
    
    if (inCue && currentCueText) {
        vttItems.push({
            startTime: currentCueStart,
            endTime: currentCueEnd,
            text: currentCueText.trim(),
            startTimeString: this.formatTimeForDisplay(currentCueStart)
        });
    }
    
    return vttItems;
}

extractWordTimings(vttContent) {
    const words = [];
    const lines = vttContent.split(/\r?\n/);
    
    for (const line of lines) {
        const wordMatches = line.matchAll(/<(\d{2}:\d{2}:\d{2}\.\d{3})>([^<]+)<\/?(\d{2}:\d{2}:\d{2}\.\d{3})>/g);
        
        for (const match of wordMatches) {
            const startTime = this.parseTimestamp(match[1]);
            const text = match[2].trim();
            const endTime = this.parseTimestamp(match[3]);
            
            if (text) {
                words.push({ text, startTime, endTime });
            }
        }
    }
    
    return words;
}

renderSubtitleList(subtitlesToRender) {
    this.subtitleList.innerHTML = '';
    
    if (subtitlesToRender.length === 0) {
        this.subtitleList.innerHTML = '<p class="info-text">No subtitles found or match your search.</p>';
        return;
    }
    
    subtitlesToRender.forEach((subtitle, index) => {
        const subtitleItem = document.createElement('div');
        subtitleItem.className = 'subtitle-item';
        subtitleItem.dataset.index = index;
        subtitleItem.dataset.startTime = subtitle.startTime;
        subtitleItem.dataset.endTime = subtitle.endTime;
        
        subtitleItem.innerHTML = `
            <div class="d-flex justify-content-between align-items-center">
                <span class="time-stamp">${subtitle.startTimeString}</span>
                <button class="create-marker-from-subtitle" title="Create marker from this subtitle">+</button>
            </div>
            <span class="subtitle-text">${subtitle.text}</span>
        `;
        
        subtitleItem.addEventListener('click', (e) => {
            if (e.target.classList.contains('create-marker-from-subtitle')) return;
            
            const allItems = this.subtitleList.querySelectorAll('.subtitle-item');
            allItems.forEach(item => item.classList.remove('active'));
            subtitleItem.classList.add('active');
            
            this.videoController.setSelection(subtitle.startTime, subtitle.endTime);
            this.videoController.seekTo(subtitle.startTime);
            this.video.pause();
        });
        
        subtitleItem.querySelector('.create-marker-from-subtitle').addEventListener('click', (e) => {
            e.stopPropagation();
            this.createMarkerFromSubtitle(subtitle);
        });
        
        this.subtitleList.appendChild(subtitleItem);
    });
}

renderTranscript(vttContent) {
    this.subtitleList.innerHTML = '';
    
    if (this.state.wordTimings.length === 0) {
        this.renderSubtitleList(this.state.subtitles);
        return;
    }
    
    const transcriptContainer = document.createElement('div');
    transcriptContainer.className = 'json-transcript';
    
    let currentSegmentIndex = 0;
    let segmentContainer = document.createElement('div');
    segmentContainer.className = 'transcript-segment';
    segmentContainer.dataset.index = currentSegmentIndex;
    
    if (this.state.subtitles.length > 0) {
        segmentContainer.dataset.startTime = this.state.subtitles[0].startTime;
        segmentContainer.dataset.endTime = this.state.subtitles[0].endTime;
        
        const timeStamp = document.createElement('span');
        timeStamp.className = 'time-stamp';
        timeStamp.textContent = this.formatTimeForDisplay(this.state.subtitles[0].startTime);
        segmentContainer.appendChild(timeStamp);
        
        const createMarkerBtn = document.createElement('button');
        createMarkerBtn.className = 'create-marker-from-subtitle float-end';
        createMarkerBtn.title = 'Create marker from this segment';
        createMarkerBtn.textContent = '+';
        createMarkerBtn.dataset.segmentIndex = '0';
        createMarkerBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const segmentIndex = parseInt(createMarkerBtn.dataset.segmentIndex);
            this.createMarkerFromSubtitle(this.state.subtitles[segmentIndex]);
        });
        segmentContainer.appendChild(createMarkerBtn);
    }
    
    this.state.wordTimings.forEach((word, index) => {
        while (currentSegmentIndex < this.state.subtitles.length - 1 && 
                word.startTime >= this.state.subtitles[currentSegmentIndex + 1].startTime) {
            transcriptContainer.appendChild(segmentContainer);
            
            currentSegmentIndex++;
            segmentContainer = document.createElement('div');
            segmentContainer.className = 'transcript-segment';
            segmentContainer.dataset.index = currentSegmentIndex;
            segmentContainer.dataset.startTime = this.state.subtitles[currentSegmentIndex].startTime;
            segmentContainer.dataset.endTime = this.state.subtitles[currentSegmentIndex].endTime;
            
            const timeStamp = document.createElement('span');
            timeStamp.className = 'time-stamp';
            timeStamp.textContent = this.formatTimeForDisplay(this.state.subtitles[currentSegmentIndex].startTime);
            segmentContainer.appendChild(timeStamp);
            
            const createMarkerBtn = document.createElement('button');
            createMarkerBtn.className = 'create-marker-from-subtitle float-end';
            createMarkerBtn.title = 'Create marker from this segment';
            createMarkerBtn.textContent = '+';
            createMarkerBtn.dataset.segmentIndex = currentSegmentIndex.toString();
            createMarkerBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const segmentIndex = parseInt(e.target.dataset.segmentIndex);
                this.createMarkerFromSubtitle(this.state.subtitles[segmentIndex]);
            });
            segmentContainer.appendChild(createMarkerBtn);
        }
        
        const wordSpan = document.createElement('span');
        wordSpan.className = 'transcript-word';
        wordSpan.textContent = word.text;
        wordSpan.dataset.start = word.startTime;
        wordSpan.dataset.end = word.endTime;
        
        wordSpan.addEventListener('click', (e) => {
            e.stopPropagation();
            this.videoController.setSelection(word.startTime, word.endTime);
            this.videoController.seekTo(word.startTime);
            this.video.pause();
        });
        
        segmentContainer.appendChild(wordSpan);
        
        if (index < this.state.wordTimings.length - 1) {
            segmentContainer.appendChild(document.createTextNode(' '));
        }
    });
    
    transcriptContainer.querySelectorAll('.transcript-segment').forEach(seg => {
        seg.addEventListener('click', (e) => {
            if (e.target.classList.contains('transcript-word') || 
                e.target.classList.contains('create-marker-from-subtitle')) return;
            
            const start = parseFloat(seg.dataset.startTime);
            const end = parseFloat(seg.dataset.endTime);
            this.videoController.setSelection(start, end);
            this.videoController.seekTo(start);
            this.video.pause();
        });
    });
    
    if (segmentContainer.childNodes.length > 0) {
        transcriptContainer.appendChild(segmentContainer);
    }
    
    this.subtitleList.appendChild(transcriptContainer);
}

updateCurrentSubtitle() {
    if (!this.state.subtitles.length) return;
    
    const currentTime = this.video.currentTime;
    const index = this.state.subtitles.findIndex(sub => 
        currentTime >= sub.startTime && currentTime <= sub.endTime
    );
    
    if (index !== this.state.currentSubtitleIndex) {
        this.state.currentSubtitleIndex = index;
        const activeItems = this.subtitleList.querySelectorAll('.active');
        activeItems.forEach(item => item.classList.remove('active'));
        
        if (index !== -1) {
            const currentSubtitle = this.state.subtitles[index];
            if (this.state.subtitleFormat === "vtt" && this.state.wordTimings.length > 0) {
                const wordsInCue = this.state.wordTimings.filter(w => 
                    w.startTime >= currentSubtitle.startTime && w.endTime <= currentSubtitle.endTime
                );
                let subtitleHTML = "";
                wordsInCue.forEach(word => {
                    const isActive = currentTime >= word.startTime && currentTime <= word.endTime;
                    subtitleHTML += `<span class="video-subtitle-word ${isActive ? 'word-active' : ''}" data-start="${word.startTime}">${word.text}</span> `;
                });
                this.currentSubtitleDisplay.innerHTML = subtitleHTML.trim();
            } else {
                this.currentSubtitleDisplay.textContent = currentSubtitle.text;
            }
            
            const elementToActivate = this.subtitleList.querySelector(`[data-index='${index}']`);
            if (elementToActivate) {
                elementToActivate.classList.add('active');
                if (!this.video.paused || document.activeElement !== this.video) {
                    this.scrollElementIntoViewIfNeeded(elementToActivate, this.subtitleList);
                }
            }
            
            if (this.state.subtitleFormat === "vtt") {
                this.updateCurrentWord(currentTime);
            }
        } else {
            this.currentSubtitleDisplay.textContent = '';
        }
    } else if (this.state.subtitleFormat === "vtt" && index !== -1) {
        const currentWords = this.currentSubtitleDisplay.querySelectorAll('.video-subtitle-word');
        currentWords.forEach(word => {
            const start = parseFloat(word.dataset.start);
            const isActive = currentTime >= start && currentTime <= (start + 0.5); // Adjust tolerance as needed
            word.classList.toggle('word-active', isActive);
        });
        
        this.updateCurrentWord(currentTime);
    }
}

updateCurrentWord(currentTime) {
    const activeWords = this.subtitleList.querySelectorAll('.word-active');
    activeWords.forEach(word => word.classList.remove('word-active'));
    
    const words = this.subtitleList.querySelectorAll('.transcript-word');
    let activeWordFound = false;
    
    words.forEach(word => {
        const start = parseFloat(word.dataset.start);
        const end = parseFloat(word.dataset.end);
        
        if (currentTime >= start && currentTime <= end) {
            word.classList.add('word-active');
            activeWordFound = true;
            
            const isPlaying = !this.video.paused;
            if (!isPlaying || document.activeElement !== this.video) {
                this.scrollElementIntoViewIfNeeded(word, this.subtitleList);
            }
        }
    });
    
    return activeWordFound;
}

createMarkerFromSubtitle(subtitle) {
    if (!this.video.duration) return;
    
    this.videoController.setSelection(subtitle.startTime, subtitle.endTime);
    
    const frameRate = this.videoController.state.frameRate;
    const newMarker = {
        start: subtitle.startTime,
        end: subtitle.endTime,
        duration: subtitle.endTime - subtitle.startTime,
        comments: [{
            text: subtitle.text,
        }]
    };
    
    // STEP 1: Add marker to array
    this.videoController.state.markers.push(newMarker);
    
    // STEP 2: Sort markers by start time (this also re-renders everything)
    this.sortMarkers();
    
    // STEP 3: Find the new index of our marker after sorting (by object reference)
    const newMarkerIndex = this.videoController.state.markers.indexOf(newMarker);
    this.videoController.state.activeMarkerIndex = newMarkerIndex;
    
    // Enable the edit button since we now have an active marker
    this.updateEditMarkerButtonState();
    
}

// ============================================ 
// COMPLETE SEARCH FUNCTIONALITY METHODS 
// Add these to AppController class 
// ============================================ 

filterSubtitles() {
    const searchTerm = this.searchBox.value.toLowerCase().trim();
    
    // Reset highlights
    document.querySelectorAll('.search-match, .current-match').forEach(el => {
        el.classList.remove('search-match', 'current-match');
        const originalText = el.dataset.originalText;
        if (originalText) {
            el.innerHTML = originalText;
        }
    });
    
    this.state.searchMatches = [];
    this.state.currentMatchIndex = -1;
    this.updateSearchResultsUI();
    
    if (!searchTerm) {
        if (this.state.subtitleFormat === "vtt") {
            this.subtitleList.querySelectorAll('.transcript-word').forEach(word => {
                word.classList.remove('search-match', 'current-match');
            });
        }
        return;
    }
    
    let matchesFound = [];
    
    if (this.state.subtitleFormat === 'vtt' && this.state.wordTimings.length > 0) {
        const allWords = Array.from(this.subtitleList.querySelectorAll('.transcript-word'));
        const searchWords = searchTerm.split(/\s+/);
        
        for (let i = 0; i <= allWords.length - searchWords.length; i++) {
            let potentialMatch = [];
            let fullMatch = true;
            
            for (let j = 0; j < searchWords.length; j++) {
                const wordElement = allWords[i + j];
                const wordText = wordElement.textContent.toLowerCase();
                if (wordText.includes(searchWords[j])) {
                    potentialMatch.push(wordElement);
                } else {
                    fullMatch = false;
                    break;
                }
            }
            
            if (fullMatch) {
                let isContiguous = true;
                for (let k = 0; k < potentialMatch.length - 1; k++) {
                    const end = parseFloat(potentialMatch[k].dataset.end);
                    const start = parseFloat(potentialMatch[k+1].dataset.start);
                    if (start - end > 1.0) { // Allow for small gaps between words
                        isContiguous = false;
                        break;
                    }
                }
                
                if(isContiguous) {
                    matchesFound.push(potentialMatch);
                    i += potentialMatch.length - 1; // Skip ahead to avoid overlapping matches within the same phrase
                }
            }
        }
        
        matchesFound.forEach(phrase => phrase.forEach(word => word.classList.add('search-match')));
    } else {
        const items = this.subtitleList.querySelectorAll('.subtitle-item, .transcript-segment');
        items.forEach(item => {
            const textElement = item.querySelector('.subtitle-text') || item;
            const originalText = textElement.textContent;
            if (originalText.toLowerCase().includes(searchTerm)) {
                if(item.classList.contains('subtitle-item')) {
                    const regex = new RegExp(`(${searchTerm.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')})`, 'gi');
                    textElement.dataset.originalText = originalText;
                    textElement.innerHTML = originalText.replace(regex, '<span class="search-match">$1</span>');
                } else {
                    item.classList.add('search-match');
                }
                matchesFound.push(item);
            }
        });
    }
    
    if (matchesFound.length > 0) {
        this.state.searchMatches = matchesFound;
        this.state.currentMatchIndex = 0;
        this.highlightCurrentMatch();
    }
    
    this.updateSearchResultsUI();
}

navigateToPreviousMatch() {
    if (this.state.searchMatches.length === 0) return;
    this.state.currentMatchIndex = (this.state.currentMatchIndex > 0) 
        ? this.state.currentMatchIndex - 1 
        : this.state.searchMatches.length - 1;
    this.highlightCurrentMatch();
}

navigateToNextMatch() {
    if (this.state.searchMatches.length === 0) return;
    this.state.currentMatchIndex = (this.state.currentMatchIndex < this.state.searchMatches.length - 1) 
        ? this.state.currentMatchIndex + 1 
        : 0;
    this.highlightCurrentMatch();
}

highlightCurrentMatch() {
    document.querySelectorAll('.current-match').forEach(el => el.classList.remove('current-match'));
    
    if (this.state.searchMatches.length === 0 || this.state.currentMatchIndex === -1) return;
    
    const currentMatch = this.state.searchMatches[this.state.currentMatchIndex];
    let firstElement;
    let selectionStart, selectionEnd;
    
    if (Array.isArray(currentMatch)) {
        currentMatch.forEach(el => el.classList.add('current-match'));
        firstElement = currentMatch[0];
        selectionStart = parseFloat(firstElement.dataset.start);
        selectionEnd = parseFloat(currentMatch[currentMatch.length - 1].dataset.end);
    } else {
        currentMatch.classList.add('current-match');
        firstElement = currentMatch;
        if (firstElement.classList.contains('transcript-word')) {
            selectionStart = parseFloat(firstElement.dataset.start);
            selectionEnd = parseFloat(firstElement.dataset.end);
        } else {
            const index = parseInt(firstElement.dataset.index);
            if (!isNaN(index) && this.state.subtitles[index]) {
                selectionStart = this.state.subtitles[index].startTime;
                selectionEnd = this.state.subtitles[index].endTime;
            }
        }
    }
    
    if (firstElement) {
        this.scrollElementIntoViewIfNeeded(firstElement, this.subtitleList);
    }
    
    if(selectionStart !== undefined && selectionEnd !== undefined) {
        this.videoController.setSelection(selectionStart, selectionEnd);
    }
    
    this.updateSearchResultsUI();
}

addSearchResultsAsMarkers() {
    if (!this.state.searchMatches.length || !this.video.duration) {
        alert('No search results found or video not loaded.');
        return;
    }
    
    const applyPadding = this.applySearchPaddingCheckbox.checked;
    let paddingDuration = 0;
    let paddingMode = 'mid';
    
    if (applyPadding) {
        const minutes = parseInt(this.minutesInput.value) || 0;
        const seconds = parseInt(this.secondsInput.value) || 0;
        const frames = parseInt(this.framesInput.value) || 0;
        const frameRate = this.videoController.state.frameRate;
        paddingDuration = minutes * 60 + seconds + (frames / frameRate);
        paddingMode = this.playheadPositionSelect.value;
        
        if(paddingDuration <= 0) {
            alert("Please set a positive duration in the 'Precise Range Duration' controls to use for padding.");
            return;
        }
    }
    
    let newMarkersCount = 0;
    const frameRate = this.videoController.state.frameRate;
    
    this.state.searchMatches.forEach(match => {
        let originalStart, originalEnd, text;
        
        if(Array.isArray(match)) {
            originalStart = parseFloat(match[0].dataset.start);
            originalEnd = parseFloat(match[match.length-1].dataset.end);
            text = match.map(el => el.textContent).join(' ');
        } else {
            const index = parseInt(match.dataset.index);
            if(!isNaN(index) && this.state.subtitles[index]) {
                const sub = this.state.subtitles[index];
                originalStart = sub.startTime;
                originalEnd = sub.endTime;
                text = sub.text;
            }
        }
        
        if(originalStart !== undefined) {
            let finalStart = originalStart;
            let finalEnd = originalEnd;
            
            if (applyPadding) {
                switch (paddingMode) {
                    case 'in':
                        finalStart = originalStart;
                        finalEnd = originalStart + paddingDuration;
                        break;
                    case 'out':
                        finalEnd = originalEnd;
                        finalStart = originalEnd - paddingDuration;
                        break;
                    case 'mid':
                        const midpoint = originalStart + (originalEnd - originalStart) / 2;
                        finalStart = midpoint - (paddingDuration / 2);
                        finalEnd = midpoint + (paddingDuration / 2);
                        break;
                }
            }
            
            finalStart = Math.max(0, finalStart);
            finalEnd = Math.min(this.video.duration, finalEnd);
            
            if (finalStart < finalEnd) {
                this.videoController.state.markers.push({
                    start: finalStart,
                    end: finalEnd,
                    duration: finalEnd - finalStart,
                    comments: [{
                        text: text,
                    }]
                });
                newMarkersCount++;
            }
        }
    });
    
    if (newMarkersCount > 0) {
        this.sortMarkers();
        document.getElementById('markers-tab').click();
        alert(`Added ${newMarkersCount} new markers from search results.`);
    }
}

updateSearchResultsUI() {
    const hasMatches = this.state.searchMatches.length > 0;
    
    this.searchNavigation.style.display = hasMatches ? 'flex' : 'none';
    
    const addMarkersBtn = document.getElementById('add-search-markers');
    if (addMarkersBtn) {
        addMarkersBtn.style.display = hasMatches ? 'block' : 'none';
    }
    
    if (hasMatches) {
        document.getElementById('search-count').textContent = 
            `${this.state.currentMatchIndex + 1} of ${this.state.searchMatches.length}`;
    } else {
        document.getElementById('search-count').textContent = `0 results`;
    }
}

updateSearchClearButton() {
    this.searchClearBtn.style.display = this.searchBox.value.trim() ? 'block' : 'none';
}

clearSearch() {
    this.searchBox.value = '';
    this.updateSearchClearButton();
    this.filterSubtitles();
}

updateMarkerSearchClearButton() {
    this.markerSearchClearBtn.style.display = this.markerSearchInput.value.trim() ? 'block' : 'none';
}

clearMarkerSearch() {
    this.markerSearchInput.value = '';
    this.updateMarkerSearchClearButton();
    this.updateMarkersList();
}


// ============================================ 
// COMPLETE JSON IMPORT/EXPORT & UTILITY METHODS 
// Add these to AppController class 
// ============================================ 

async handleJSONImport(file) {
    try {
        const text = await file.text();
        const jsonData = JSON.parse(text);
        
        if (jsonData.video && jsonData.clips) {
            if (jsonData.video.file.media.video.timecode.rate.timebase) {
                const jsonFrameRate = parseFloat(jsonData.video.file.media.video.timecode.rate.timebase);
                this.framerateSelect.value = jsonFrameRate.toString();
                this.videoController.state.frameRate = jsonFrameRate;
            }
            
            this.videoController.state.markers = jsonData.clips.map(clip => ({
                start: clip.start / this.videoController.state.frameRate,
                end: clip.end / this.videoController.state.frameRate,
                duration: (clip.end - clip.start) / this.videoController.state.frameRate,
                comments: clip.comments || []
            }));
            
            this.sortMarkers();
            
            if (jsonData.waveform) {
                this.state.importedWaveformData = jsonData.waveform;
                this.videoController.initWaveform(jsonData.waveform);
            }
        } else {
            throw new Error('Invalid JSON format. Expected a project file with video and clips data.');
        }
    } catch (error) {
        console.error('Error importing JSON:', error);
        alert('Error importing project file. Please check the file format.');
    }
}

async saveJSON() {
    if (!this.video.duration) {
        alert('Please load a video first.');
        return;
    }
    
    if (!this.state.audioInfo.samplerate) {
        this.state.audioInfo = await this.detectAudioInfo(this.video);
    }
    
    const customPath = this.customPathInput.value.trim();
    if (customPath) this.saveCustomPath(customPath);
    const pathUrl = customPath || `C:/Videos/`;
    
    const frameRate = this.videoController.state.frameRate;
    const videoData = {
        "sequence": { "name": this.state.originalFileName.split('.')[0] },
        "video": {
            "file": {
                "name": this.state.originalFileName,
                "pathurl": pathUrl + this.state.originalFileName,
                "media": {
                    "video": {
                        "duration": Math.round(this.video.duration * frameRate),
                        "timecode": {
                            "rate": {
                                "ntsc": [29.97, 59.94, 23.976].includes(frameRate) ? "TRUE" : "FALSE",
                                "timebase": frameRate
                            },
                            "displayformat": "NDF",
                            "first_timecode": "00:00:00:00"
                        },
                        "samplecharacteristics": {
                            "width": this.video.videoWidth,
                            "height": this.video.videoHeight,
                            "anamorphic": "FALSE",
                            "pixelaspectratio": "Square"
                        }
                    },
                    "audio": {
                        "samplecharacteristics": {
                            "depth": 16,
                            "samplerate": this.state.audioInfo.samplerate.toString()
                        },
                        "channelcount": this.state.audioInfo.channelcount
                    }
                }
            }
        },
		"clips": this.videoController.state.markers.map((marker, index) => ({
			"id": (index + 1).toString(),
			"start": Math.round(marker.start * frameRate),
			"end": Math.round(marker.end * frameRate),
			"comments": marker.comments ? marker.comments.map(sub => ({
				text: sub.text
			})) : []
		}))
		
    };
    
    if (this.state.importedWaveformData) {
        videoData.waveform = this.state.importedWaveformData;
    }
    
    const blob = new Blob([JSON.stringify(videoData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${this.state.originalFileName.split('.')[0]}-project.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// ============================================ 
// UTILITY FUNCTIONS 
// ============================================ 

timeToSeconds(timeString) {
    if (typeof timeString === 'number') return timeString;
    
    if (timeString.includes(',')) {
        const [time, milliseconds] = timeString.split(',');
        const [hours, minutes, seconds] = time.split(':').map(Number);
        return hours * 3600 + minutes * 60 + seconds + parseInt(milliseconds) / 1000;
    }
    
    return this.parseTimestamp(timeString);
}

parseTimestamp(timestamp) {
    const match = timestamp.match(/(\d+):(\d+):(\d+)\.(\d+)/);
    if (match) {
        const hours = parseInt(match[1], 10);
        const minutes = parseInt(match[2], 10);
        const seconds = parseInt(match[3], 10);
        const milliseconds = parseInt(match[4], 10);
        return hours * 3600 + minutes * 60 + seconds + milliseconds / 1000;
    }
    
    const shortMatch = timestamp.match(/(\d+):(\d+)\.(\d+)/);
    if (shortMatch) {
        const minutes = parseInt(shortMatch[1], 10);
        const seconds = parseInt(shortMatch[2], 10);
        const milliseconds = parseInt(shortMatch[3], 10);
        return minutes * 60 + seconds + milliseconds / 1000;
    }
    
    return 0;
}

formatTimeForDisplay(timeInSeconds) {
    const minutes = Math.floor(timeInSeconds / 60);
    const seconds = Math.floor(timeInSeconds % 60);
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

scrollElementIntoViewIfNeeded(element, container) {
    if (!element || !container) return;
    
    const containerHeight = container.clientHeight;
    const scrollTop = container.scrollTop;
    const elementTop = element.offsetTop - container.offsetTop;
    const elementHeight = element.offsetHeight;
    
    const isAbove = elementTop < scrollTop;
    const isBelow = (elementTop + elementHeight) > (scrollTop + containerHeight);
    
    if (isAbove || isBelow) {
        const targetScroll = elementTop - (containerHeight / 2) + (elementHeight / 2);
        container.scrollTo({
            top: targetScroll,
            behavior: 'smooth'
        });
    }
}

debounce(func, wait) {
    let timeout;
    return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
    };
}

updateFramesInputMax() {
    const frameRate = this.videoController.state.frameRate;
    const maxFrames = Math.ceil(frameRate);
    this.framesInput.max = maxFrames - 1;
    this.framesInput.placeholder = `0-${maxFrames - 1}`;
    if (parseInt(this.framesInput.value) >= maxFrames) {
        this.framesInput.value = 0;
    }
}

updatePathDropdown() {
    const savedPaths = JSON.parse(localStorage.getItem('customPaths') || '[]');
    
    while (this.savedPathsSelect.options.length > 1) {
        this.savedPathsSelect.remove(1);
    }
    
    savedPaths.forEach(path => {
        const option = document.createElement('option');
        option.value = path;
        option.textContent = path;
        this.savedPathsSelect.appendChild(option);
    });
}

saveCustomPath(path) {
    const savedPaths = JSON.parse(localStorage.getItem('customPaths') || '[]');
    const existingIndex = savedPaths.indexOf(path);
    if (existingIndex !== -1) savedPaths.splice(existingIndex, 1);
    savedPaths.unshift(path);
    if (savedPaths.length > 5) savedPaths.pop();
    localStorage.setItem('customPaths', JSON.stringify(savedPaths));
    this.updatePathDropdown();
}

async detectAudioInfo(video) {
    try {
        if (!this.state.audioContext) {
            this.state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = this.state.audioContext.createMediaElementSource(video);
            source.connect(this.state.audioContext.destination);
        }
        return {
            samplerate: this.state.audioContext.sampleRate,
            channelcount: (video.mozChannels || video.webkitAudioChannelCount || 2)
        };
    } catch (e) {
        console.warn('Could not detect audio info:', e);
        return { samplerate: 48000, channelcount: 2 };
    }
}

resetWaveform() {
    const waveformContainer = document.getElementById('waveform-scroll-container');
    const waveformMessage = document.getElementById('waveform-message');
    const loadingIndicator = document.getElementById('loading-indicator');
    
    this.state.importedWaveformData = null;
    this.videoController.state.isWaveformReady = false;
    
    if (waveformContainer) waveformContainer.style.display = 'none';
    if (waveformMessage) waveformMessage.style.display = 'none';
    if (loadingIndicator) loadingIndicator.style.display = 'none';
    
    if (this.videoController.wavesurfer) {
        this.videoController.wavesurfer.destroy();
        this.videoController.wavesurfer = null;
        this.videoController.selectionRegion = null;
    }
}

// ============================================ 
// CLEANUP 
// ============================================ 
destroy() {
    if (this.videoController) {
        this.videoController.destroy();
    }
    
    if (this.state.currentVideoUrl) {
        URL.revokeObjectURL(this.state.currentVideoUrl);
    }
    
    if (this.state.audioContext && this.state.audioContext.state !== 'closed') {
        this.state.audioContext.close();
    }
}
} // End of AppController class

// ============================================ 
// FINAL INITIALIZATION CODE 
// This goes at the END of the file, after VideoTimelineController and AppController classes 
// ============================================ 

        // End of AppController class
        
        // ============================================ 
        // INITIALIZE APPLICATION 
        // ============================================ 
        const app = new AppController();
        window.app = app; // Make app globally accessible
        
        // ============================================ 
        // ENSURE VIDEO CONTROLS ALWAYS VISIBLE 
        // ============================================ 
        const style = document.createElement('style');
        style.textContent = `
            video::-webkit-media-controls-panel {
                display: flex !important;
                opacity: 1 !important;
                visibility: visible !important;
            }
            video::-webkit-media-controls-timeline {
                display: flex !important;
                opacity: 1 !important;
                visibility: visible !important;
            }
            video::-webkit-media-controls {
                display: flex !important;
                opacity: 1 !important;
                visibility: visible !important;
            }
            video::-webkit-media-controls-enclosure {
                display: flex !important;
                opacity: 1 !important;
                visibility: visible !important;
            }
            video {
                controls: true;
            }
            video::-moz-media-controls-panel {
                opacity: 1 !important;
                visibility: visible !important;
            }
            #my_video {
                controls: true;
            }
            video:hover::-webkit-media-controls-panel,
            video::-webkit-media-controls-panel {
                opacity: 1 !important;
                transition: none !important;
            }
        `;
        document.head.appendChild(style);
        
        // Ensure the video element always has controls attribute
        const video = document.getElementById('my_video');
        if (video) {
            video.setAttribute('controls', 'true');
            video.setAttribute('controlsList', 'nodownload');
        }
        
        // ============================================ 
        // HANDLE PAGE UNLOAD 
        // ============================================ 
        window.addEventListener('beforeunload', function() {
            app.destroy();
        });
        
        // ============================================ 
        // HANDLE WINDOW RESIZE 
        // ============================================ 
        window.addEventListener('resize', app.debounce(function() {
            if (app.video.duration) {
                app.videoController.updateTimeDisplaysCached();
            }
            
            // Adjust waveform zoom on resize
            if (app.videoController.state.isWaveformReady && app.videoController.wavesurfer) {
                const waveformContainer = document.getElementById('waveform-scroll-container');
                const isMobile = window.innerWidth <= 768;
                const pxPerSec = waveformContainer.clientWidth / (isMobile ? 15 : 5);
                app.videoController.wavesurfer.zoom(pxPerSec);
            }
        }, 250));
        
        // ============================================ 
        // PREVENT BUTTONS FROM STAYING FOCUSED 
        // ============================================ 
        document.querySelectorAll('button').forEach(button => {
            button.addEventListener('click', function() {
                if (this !== app.playPauseBtn) {
                    setTimeout(() => this.blur(), 100);
                }
            });
        });
        
    }); // End of jQuery ready
}); // End of DOMContentLoaded
