// ============================================
// OPTIMIZED SUPERCUT AND MARKER VIDEO EDITOR
// This is a complete rewrite with performance improvements
// ============================================

document.addEventListener('DOMContentLoaded', function() {
    $(function() {
        
        // ============================================
        // VIDEO TIMELINE CONTROLLER CLASS
        // ============================================
        class VideoTimelineController {
            constructor(config) {
                // DOM elements
                this.video = config.video;
                this.mainTimeline = config.mainTimeline;
                this.mainTimelineSelection = config.mainTimelineSelection;
                this.mainTimelinePlayhead = config.mainTimelinePlayhead;
                this.currentTimeDisplay = config.currentTimeDisplay;
                this.durationTimeDisplay = config.durationTimeDisplay;
                this.selectionTimeDisplay = config.selectionTimeDisplay;
                this.selectionDurationDisplay = config.selectionDurationDisplay;
                this.detectedFpsDisplay = config.detectedFpsDisplay;
                this.framerateSelect = config.framerateSelect;
                
                // State management
                this.state = {
                    frameRate: 29.97,
                    duration: 0,
                    currentTime: 0,
                    selection: { start: 0, end: 0 },
                    isWaveformReady: false,
                    isSeeking: false,
                    isLooping: false,
                    isDragging: false,
                    markers: [],
                    activeMarkerIndex: -1
                };
                
                // Performance optimization
                this.rafId = null;
                this.lastUpdateTime = 0;
                this.updateThrottle = 1000 / 60; // 60fps max
                
                // WaveSurfer instance
                this.wavesurfer = null;
                this.selectionRegion = null;
                
                // FPS detection
                this.fpsDetector = {
                    lastMediaTime: 0,
                    lastFrameNum: 0,
                    fpsRounder: [],
                    frameNotSeeked: true,
                    detectedFps: 0,
                    isComplete: false  // Stop after detection
                };
                
                // SMPTE cache
                this.smpteCache = new Map();
                this.lastCacheTime = -1;
                this.lastScaleUpdate = -1;
                
                // Bind methods
                this.updatePlayhead = this.updatePlayhead.bind(this);
                this.handleTimeUpdate = this.handleTimeUpdate.bind(this);
                this.ticker = this.ticker.bind(this);
                
                this.init();
            }
            
            init() {
                // Ensure video controls are always visible
                this.video.setAttribute('controls', 'true');
                this.video.setAttribute('controlsList', 'nodownload');
                
                // Video event listeners
                this.video.addEventListener('loadedmetadata', () => this.onVideoLoaded());
                this.video.addEventListener('timeupdate', this.handleTimeUpdate);
                this.video.addEventListener('seeking', () => { 
                    this.state.isSeeking = true;
				if (window.app) {
				window.app.renderTimelineMarkers(); // FIXED
				}	
                });
                this.video.addEventListener('seeked', () => { 
                    this.state.isSeeking = false;
                    this.fpsDetector.fpsRounder.pop();
                    this.fpsDetector.frameNotSeeked = false;
                    // Force update after seek completes
                    this.updatePlayhead(true);
                });
                this.video.addEventListener('play', () => this.onPlayStateChange(true));
                this.video.addEventListener('pause', () => this.onPlayStateChange(false));
                
                // Handle native video control seeking
                this.video.addEventListener('input', (e) => {
                    // Update our playhead when using native controls
                    this.updatePlayhead(true);
                    this.updateTimeDisplaysCached(this.video.currentTime);
                });
                
                // Timeline interaction
                this.setupTimelineInteraction();
                
                // Frame rate change handler
                this.framerateSelect.addEventListener('change', (e) => {
                    this.state.frameRate = parseFloat(e.target.value);
                    // Clear cache when frame rate changes
                    this.smpteCache.clear();
                    this.updateTimeDisplaysCached();
                });
            }
            
            onVideoLoaded() {
                this.state.duration = this.video.duration;
                this.state.selection = { start: 0, end: this.video.duration };
                
                this.updateSelection();
                this.updateTimeDisplaysCached();
                
                // Only start animation if playing
                if (!this.video.paused) {
                    this.startPlayheadAnimation();
                }
                
                // Reset FPS detection
                this.fpsDetector.isComplete = false;
                this.fpsDetector.fpsRounder = [];
                
                // Start FPS detection
                this.video.requestVideoFrameCallback(this.ticker);
            }
            
            onPlayStateChange(isPlaying) {
                document.getElementById('play-pause').textContent = isPlaying ? 'Pause' : 'Play';
                
                // Start or stop animation loop based on play state
                if (isPlaying) {
                    this.startPlayheadAnimation();
                } else {
                    this.stopPlayheadAnimation();
                    // Force update when paused to ensure current position is shown
                    this.updatePlayhead(true);
                }
            }
            
            // ============================================
            // FPS DETECTION (OPTIMIZED - STOPS AFTER DETECTION)
            // ============================================
            ticker(useless, metadata) {
                // Stop if already detected
                if (this.fpsDetector.isComplete) return;
                
                const mediaTimeDiff = Math.abs(metadata.mediaTime - this.fpsDetector.lastMediaTime);
                const frameNumDiff = Math.abs(metadata.presentedFrames - this.fpsDetector.lastFrameNum);
                const diff = mediaTimeDiff / frameNumDiff;
                
                if (diff && diff < 1 && this.fpsDetector.frameNotSeeked && 
                    this.fpsDetector.fpsRounder.length < 50 && 
                    this.video.playbackRate === 1 && document.hasFocus()) {
                    
                    this.fpsDetector.fpsRounder.push(diff);
                    const avgFps = this.fpsDetector.fpsRounder.reduce((a, b) => a + b) / this.fpsDetector.fpsRounder.length;
                    this.fpsDetector.detectedFps = Math.round(1 / avgFps);
                    
                    const certainty = this.fpsDetector.fpsRounder.length * 2;
                    this.detectedFpsDisplay.textContent = `${this.fpsDetector.detectedFps} fps (${certainty}%)`;
                    
                    if (certainty >= 50) {
                        const closestRate = this.findClosestFrameRate(this.fpsDetector.detectedFps);
                        this.framerateSelect.value = closestRate.toString();
                        this.state.frameRate = closestRate;
                        this.updateTimeDisplaysCached();
                    }
                    
                    // Stop detection after 50 samples
                    if (this.fpsDetector.fpsRounder.length >= 50) {
                        this.fpsDetector.isComplete = true;
                        this.detectedFpsDisplay.textContent += ' âœ“';
                        return; // Stop requesting frames
                    }
                }
                
                this.fpsDetector.frameNotSeeked = true;
                this.fpsDetector.lastMediaTime = metadata.mediaTime;
                this.fpsDetector.lastFrameNum = metadata.presentedFrames;
                
                // Continue detection
                if (!this.fpsDetector.isComplete) {
                    this.video.requestVideoFrameCallback(this.ticker);
                }
            }
            
            findClosestFrameRate(detectedFps) {
                const frameRates = [23.976, 24, 25, 29.97, 30, 50, 59.94, 60];
                return frameRates.reduce((prev, curr) => 
                    Math.abs(curr - detectedFps) < Math.abs(prev - detectedFps) ? curr : prev
                );
            }
            
            // ============================================
            // UNIFIED SEEK FUNCTION
            // ============================================
            seekTo(time, source = 'user') {
                if (!this.state.duration) return;
                
                // Prevent circular updates
                if (this.state.isSeeking && source === 'sync') return;
                
                // Clamp time
                time = Math.max(0, Math.min(this.state.duration, time));
                
                // Update state
                this.state.currentTime = time;
                
                // Single source of truth
                if (this.state.isWaveformReady && this.wavesurfer) {
                    // Use seekAndCenter to both seek and center the view
                    if (Math.abs(this.wavesurfer.getCurrentTime() - time) > 0.001) {
                        const progress = time / this.state.duration;
                        this.wavesurfer.seekAndCenter(progress);
                    }
                } else {
                    if (Math.abs(this.video.currentTime - time) > 0.001) {
                        this.video.currentTime = time;
                    }
                }
                
                // Force immediate visual update regardless of play state
                this.updatePlayhead(true);
                this.updateTimeDisplaysCached();
                
                // Reset seeking flag after a short delay to allow updates
                setTimeout(() => { this.state.isSeeking = false; }, 50);
            }
            
            // ============================================
            // OPTIMIZED PLAYHEAD UPDATE
            // ============================================
            updatePlayhead(force = false) {
                const now = performance.now();
                
                // Throttle updates only when playing
                if (!force && !this.video.paused && now - this.lastUpdateTime < this.updateThrottle) {
                    return;
                }
                
                this.lastUpdateTime = now;
                
                // Get current time from appropriate source
                const currentTime = this.state.isWaveformReady && this.wavesurfer
                    ? this.wavesurfer.getCurrentTime()
                    : this.video.currentTime;
                
                // Always update playhead position
                if (this.state.duration > 0) {
                    const position = (currentTime / this.state.duration) * 100;
                    this.mainTimelinePlayhead.style.left = `${position}%`;
                }
                
                // Update time displays with caching
                this.updateTimeDisplaysCached(currentTime);
            }
            
            // ============================================
            // ANIMATION LOOP (OPTIMIZED - RUNS ONLY WHEN PLAYING)
            // ============================================
            startPlayheadAnimation() {
                // Only start if not already running
                if (this.rafId) return;
                
                const animate = () => {
                    if (!this.video.paused && !this.state.isSeeking) {
                        this.updatePlayhead();
                    }
                    
                    // Continue only if video is playing
                    if (!this.video.paused) {
                        this.rafId = requestAnimationFrame(animate);
                    } else {
                        this.rafId = null;
                    }
                };
                
                // Start only if playing
                if (!this.video.paused) {
                    animate();
                }
            }
            
            stopPlayheadAnimation() {
                if (this.rafId) {
                    cancelAnimationFrame(this.rafId);
                    this.rafId = null;
                }
            }
            
            // ============================================
            // TIMELINE INTERACTION (OPTIMIZED WITH TIMESTAMP THROTTLING)
            // ============================================
            setupTimelineInteraction() {
                let lastDragTime = 0;
                const dragThrottle = 16; // ~60fps
                
                const getTimeFromPosition = (e) => {
                    const rect = this.mainTimeline.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const percent = Math.max(0, Math.min(1, x / rect.width));
                    return percent * this.state.duration;
                };
                
                const handleDrag = (e) => {
                    if (!this.state.isDragging || !this.state.duration) return;
                    
                    // Timestamp-based throttling
                    const now = performance.now();
                    if (now - lastDragTime < dragThrottle) return;
                    lastDragTime = now;
                    
                    const time = getTimeFromPosition(e);
                    this.seekTo(time, 'timeline');
                    e.preventDefault();
                };
                
                // Mouse events
                this.mainTimeline.addEventListener('mousedown', (e) => {
                    if (!this.state.duration) return;
                    this.state.isDragging = true;
                    const time = getTimeFromPosition(e);
                    this.seekTo(time, 'timeline');
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', handleDrag);
                document.addEventListener('mouseup', () => {
                    if (this.state.isDragging) {
                        this.state.isDragging = false;
                        // Final update after drag ends
                        this.updatePlayhead(true);
                    }
                });
                
                // Touch events with timestamp throttling
                let lastTouchTime = 0;
                
                this.mainTimeline.addEventListener('touchstart', (e) => {
                    if (!this.state.duration) return;
                    this.state.isDragging = true;
                    const touch = e.touches[0];
                    const rect = this.mainTimeline.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const percent = Math.max(0, Math.min(1, x / rect.width));
                    const time = percent * this.state.duration;
                    this.seekTo(time, 'timeline');
                    e.preventDefault();
                }, { passive: false });
                
                document.addEventListener('touchmove', (e) => {
                    if (!this.state.isDragging || !this.state.duration) return;
                    
                    // Timestamp-based throttling for touch
                    const now = performance.now();
                    if (now - lastTouchTime < dragThrottle) return;
                    lastTouchTime = now;
                    
                    const touch = e.touches[0];
                    const rect = this.mainTimeline.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const percent = Math.max(0, Math.min(1, x / rect.width));
                    const time = percent * this.state.duration;
                    this.seekTo(time, 'timeline');
                    e.preventDefault();
                }, { passive: false });
                
                document.addEventListener('touchend', () => {
                    if (this.state.isDragging) {
                        this.state.isDragging = false;
                        // Final update after touch drag ends
                        this.updatePlayhead(true);
                    }
                });
            }
            
            // ============================================
            // WAVEFORM MANAGEMENT
            // ============================================
            initWaveform(waveformData = null) {
                if (this.wavesurfer) {
                    this.wavesurfer.destroy();
                    this.wavesurfer = null;
                }
                
                const waveformContainer = document.getElementById('waveform-scroll-container');
                const loadingIndicator = document.getElementById('loading-indicator');
                const waveformMessage = document.getElementById('waveform-message');
                
                loadingIndicator.style.display = 'block';
                waveformMessage.style.display = 'none';
                
                this.wavesurfer = WaveSurfer.create({
                    container: '#waveform',
                    waveColor: '#2a5298',
                    progressColor: '#1e3c72',
                    backend: 'MediaElement',
                    media: this.video,
                    height: 128,
                    responsive: true,
                    interact: true,
                    dragToSeek: false,
                    cursorColor: '#ff0000',
                    cursorWidth: 2,
                    partialRender: true,
                    pixelRatio: 1,
                    fillParent: true,
                    scrollParent: false,
                    plugins: [
                        WaveSurfer.regions.create({
                            regionsMinLength: 0.1,
                            dragSelection: false
                        })
                    ]
                });
                
                this.wavesurfer.on('ready', () => {
                    this.state.isWaveformReady = true;
                    loadingIndicator.style.display = 'none';
                    waveformContainer.style.display = 'block';
                    
                    // Zoom to show ~5 seconds
                    const pxPerSec = waveformContainer.clientWidth / 5;
                    this.wavesurfer.zoom(pxPerSec);
                    
                    this.setupWaveformRegion();

				    this.setupWaveformRegion();
				    
				    // Render any existing markers on the waveform
				    if (window.app) {
				        window.app.renderWaveformMarkerRegions();
				        // Setup edit mode handlers after waveform is ready
				        window.app.setupWaveformEditModeHandlers();
				    }
				    
				    // Dispatch custom event to signal waveform is ready
				    document.dispatchEvent(new CustomEvent('waveform-ready'));					
                    
                    waveformMessage.textContent = 'Waveform loaded successfully! ðŸŽµ Click anywhere to seek.';
                    waveformMessage.style.color = '#28a745';
                    waveformMessage.style.display = 'block';
                    setTimeout(() => { waveformMessage.style.display = 'none'; }, 6000);
                });
                
                this.wavesurfer.on('seeking', (time) => {
                    // Prevent circular seeks
                    if (Math.abs(this.video.currentTime - time) > 0.01) {
                        this.seekTo(time, 'waveform');
                    }
                });
                
                this.wavesurfer.on('audioprocess', () => {
                    if (!this.video.paused) {
                        this.updatePlayhead();
                    }
                });
                
                this.wavesurfer.on('error', (err) => {
                    console.error('WaveSurfer error:', err);
                    this.state.isWaveformReady = false;
                    loadingIndicator.style.display = 'none';
                    waveformMessage.textContent = `Failed: ${err}`;
                    waveformMessage.style.color = '#e74c3c';
                    waveformMessage.style.display = 'block';
                });
                
                // Load peaks if provided
                if (waveformData) {
                    this.loadPeaksData(waveformData);
                }
            }
            
            loadPeaksData(jsonData) {
                if (!jsonData || !jsonData.data || !jsonData.bits) {
                    console.error('Invalid waveform data');
                    return;
                }
                
                setTimeout(() => {
                    try {
                        const bits = jsonData.bits;
                        const divisor = 2 ** (bits - 1);
                        const data = Array.isArray(jsonData.data[0]) ? jsonData.data[0] : jsonData.data;
                        const peaks = data.map(p => p / divisor);
                        
                        this.wavesurfer.load(this.video, peaks);
                    } catch (err) {
                        console.error('Error loading peaks:', err);
                    }
                }, 100);
            }
            
            // ============================================
            // SELECTION MANAGEMENT
            // ============================================
            setSelection(start, end) {
                if (start === undefined || end === undefined || start > end) return;
                
                this.state.selection = { start, end };
                this.updateSelection();
                
                if (this.selectionRegion) {
                    this.selectionRegion.update({ start, end });
                }
            }
            
            updateSelection() {
                if (!this.state.duration) return;
                
                const { start, end } = this.state.selection;
                const startPercent = (start / this.state.duration) * 100;
                const endPercent = (end / this.state.duration) * 100;
                
                this.mainTimelineSelection.style.left = `${startPercent}%`;
                this.mainTimelineSelection.style.width = `${endPercent - startPercent}%`;
                
                this.updateTimeDisplaysCached();
            }
            
            setupWaveformRegion() {
                if (!this.wavesurfer) return;
                
                this.wavesurfer.regions.clear();
				// DON'T clear all regions - this removes markers!
				// Only clear/update the selection region
				
				// If selection region exists, update it
				if (this.selectionRegion) {
					this.selectionRegion.update({
						start: this.state.selection.start,
						end: this.state.selection.end
					});
				} else {				
				
					this.selectionRegion = this.wavesurfer.regions.add({
						start: this.state.selection.start,
						end: this.state.selection.end,
						color: 'rgba(33, 150, 243, 0.2)',
						drag: true,
						resize: true,
						attributes: {
							isMarker: false,  // CRITICAL: Not a marker
							isSelection: true // Identifies as selection
						}		
					});
				}					
                
                this.selectionRegion.on('update-end', () => {
                    this.setSelection(this.selectionRegion.start, this.selectionRegion.end);
                });
            }
            
            // ============================================
            // PLAYBACK CONTROL
            // ============================================
            play() {
                if (this.state.isWaveformReady && this.wavesurfer) {
                    this.wavesurfer.play();
                } else {
                    this.video.play().catch(e => console.log('Play failed:', e));
                }
                this.startPlayheadAnimation();
            }
            
            pause() {
                if (this.state.isWaveformReady && this.wavesurfer) {
                    this.wavesurfer.pause();
                } else {
                    this.video.pause();
                }
                this.stopPlayheadAnimation();
                // Force update when pausing
                this.updatePlayhead(true);
            }
            
            playPause() {
                if (this.state.isWaveformReady && this.wavesurfer) {
                    this.wavesurfer.playPause();
                } else {
                    if (this.video.paused) {
                        this.play();
                    } else {
                        this.pause();
                    }
                }
            }
            
            stop() {
                this.pause();
                this.seekTo(0);
            }
            
            stepFrame(direction) {
                const frameStep = 1 / this.state.frameRate;
                const currentTime = this.video.currentTime;
                const newTime = direction > 0 
                    ? Math.min(this.state.duration, (Math.round(currentTime * this.state.frameRate) + 1) / this.state.frameRate)
                    : Math.max(0, (Math.round(currentTime * this.state.frameRate) - 1) / this.state.frameRate);
                this.seekTo(newTime);
                // Force immediate update for frame stepping
                this.updatePlayhead(true);
                this.updateTimeDisplaysCached(newTime);
            }
            
            // ============================================
            // TIME UPDATE HANDLING
            // ============================================
            handleTimeUpdate() {
                // Handle looping
                if (this.state.isLooping) {
                    const currentTime = this.video.currentTime;
                    if (currentTime >= this.state.selection.end) {
                        this.seekTo(this.state.selection.start);
                        this.play();
                        return;
                    }
                }
                
                // Update displays only when playing
                if (!this.video.paused && !this.state.isSeeking && !this.state.isDragging) {
                    this.updatePlayhead();
                }
                
                // Trigger external update if needed
                if (window.updateCurrentSubtitle) {
                    window.updateCurrentSubtitle();
                }
            }
            
            // ============================================
            // TIME DISPLAY UTILITIES WITH CACHING
            // ============================================
            toSMPTE(seconds) {
                if (isNaN(seconds) || isNaN(this.state.frameRate)) {
                    return "00:00:00:00";
                }
                
                // Check cache
                const cacheKey = `${seconds.toFixed(3)}_${this.state.frameRate}`;
                if (this.smpteCache.has(cacheKey)) {
                    return this.smpteCache.get(cacheKey);
                }
                
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);
                const frames = Math.floor((seconds * this.state.frameRate) % this.state.frameRate);
                
                const result = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}:${frames.toString().padStart(2, '0')}`;
                
                // Cache result (limit cache size)
                if (this.smpteCache.size > 1000) {
                    this.smpteCache.clear();
                }
                this.smpteCache.set(cacheKey, result);
                
                return result;
            }
            
            updateTimeDisplaysCached(forceTime = null) {
                if (!this.video.duration || !isFinite(this.video.duration)) return;
                
                const currentTime = forceTime !== null ? forceTime : this.video.currentTime;
                
                // Skip if time hasn't changed significantly
                if (Math.abs(currentTime - this.lastCacheTime) < 0.01 && !forceTime) {
                    return;
                }
                this.lastCacheTime = currentTime;
                
                const duration = this.video.duration;
                const { start, end } = this.state.selection;
                const selectionDuration = end - start;
                
                // Batch DOM updates
                this.currentTimeDisplay.textContent = this.toSMPTE(currentTime);
                this.durationTimeDisplay.textContent = this.toSMPTE(duration);
                this.selectionTimeDisplay.textContent = 
                    `IN: ${this.toSMPTE(start)} - OUT: ${this.toSMPTE(end)}`;
                this.selectionDurationDisplay.textContent = 
                    `Duration: ${this.toSMPTE(selectionDuration)}`;
                
                // Update timeline scale only if needed
                if (window.updateTimelineScale && this.state.duration !== this.lastScaleUpdate) {
                    window.updateTimelineScale();
                    this.lastScaleUpdate = this.state.duration;
                }
            }
            
            updateTimeDisplays() {
                // Redirect to cached version
                this.updateTimeDisplaysCached();
            }
            
            // ============================================
            // CLEANUP
            // ============================================
            destroy() {
                this.stopPlayheadAnimation();
                
                if (this.wavesurfer) {
                    this.wavesurfer.destroy();
                    this.wavesurfer = null;
                }
                
                this.video.removeEventListener('timeupdate', this.handleTimeUpdate);
            }
        }
        
        // ============================================
        // APPLICATION CONTROLLER
        // ============================================
        class AppController {
            constructor() {
                // Cache DOM elements
                this.initDOMElements();
                
                // Initialize state
                this.state = {
                    originalFileName: '',
                    originalFilePath: '',
                    currentVideoUrl: null,
                    subtitles: [],
                    currentSubtitleIndex: -1,
                    subtitleFormat: 'srt',
                    wordTimings: [],
                    searchMatches: [],
                    currentMatchIndex: -1,
                    audioContext: null,
                    audioInfo: { samplerate: null, channelcount: null },
                    importedWaveformData: null
					editingMarkerIndex: -1,
                };
                
                // Initialize video controller
                this.videoController = null;
                
                // Initialize app
                this.init();
            }
            
            initDOMElements() {
                // Video elements
                this.video = document.getElementById('my_video');
                this.fileInput = document.getElementById('video-upload');
                this.jsonInput = document.getElementById('json-upload');
                this.playPauseBtn = document.getElementById('play-pause');
                this.stopBtn = document.getElementById('stop');
                this.frameBackBtn = document.getElementById('frame-back');
                this.frameForwardBtn = document.getElementById('frame-forward');
                this.framerateSelect = document.getElementById('framerate-select');
                this.currentTimeDisplay = document.getElementById('current-time-value');
                this.durationTimeDisplay = document.getElementById('duration-time-value');
                this.selectionTimeDisplay = document.getElementById('selection-time');
                this.selectionDurationDisplay = document.getElementById('selection-duration');
                this.resetZoomBtn = document.getElementById('reset-zoom');
				this.jumpToInBtn = document.getElementById('jump-to-in');
				this.jumpToOutBtn = document.getElementById('jump-to-out');
                this.markersList = document.getElementById('markers-list');
                this.addMarkerBtn = document.getElementById('add-marker');
                this.saveJsonBtn = document.getElementById('save-json');
                this.dropZone = document.getElementById('file-drop-zone');
                this.playheadPositionSelect = document.getElementById('playhead-position');
                this.customDurationInput = document.getElementById('custom-duration-input');
                this.framesInput = document.getElementById('frames-input');
                this.minutesInput = document.getElementById('minutes-input');
                this.secondsInput = document.getElementById('seconds-input');
                this.customPathInput = document.getElementById('custom-path');
                this.savePathBtn = document.getElementById('save-path');
                this.savedPathsSelect = document.getElementById('saved-paths');
                this.detectedFpsDisplay = document.getElementById('detected-fps');
                this.markerSearchInput = document.getElementById('marker-search');
                this.markerSearchClearBtn = document.getElementById('marker-search-clear-btn');
                
                // Main timeline elements
                this.mainTimeline = document.getElementById('main-timeline');
                this.mainTimelineSelection = document.getElementById('main-timeline-selection');
                this.mainTimelinePlayhead = document.getElementById('main-timeline-playhead');
                
                // Subtitle & Search elements
                this.subtitleFileInput = document.getElementById('subtitle-file');
                this.currentSubtitleDisplay = document.getElementById('current-subtitle');
                this.searchBox = document.getElementById('search-box');
                this.searchClearBtn = document.getElementById('search-clear-btn');
                this.subtitleList = document.getElementById('subtitle-list');
                this.prevMatchButton = document.getElementById('prev-match');
                this.nextMatchButton = document.getElementById('next-match');
                this.searchNavigation = document.getElementById('search-navigation');
                
                // New elements
                this.repeatBtn = document.getElementById('repeat-play');
                this.applySearchPaddingCheckbox = document.getElementById('apply-search-padding');
                this.paddingInfoText = document.getElementById('padding-info');
            }
            
            init() {
                // Initialize video controller
                this.videoController = new VideoTimelineController({
                    video: this.video,
                    mainTimeline: this.mainTimeline,
                    mainTimelineSelection: this.mainTimelineSelection,
                    mainTimelinePlayhead: this.mainTimelinePlayhead,
                    currentTimeDisplay: this.currentTimeDisplay,
                    durationTimeDisplay: this.durationTimeDisplay,
                    selectionTimeDisplay: this.selectionTimeDisplay,
                    selectionDurationDisplay: this.selectionDurationDisplay,
                    detectedFpsDisplay: this.detectedFpsDisplay,
                    framerateSelect: this.framerateSelect
                });
                
                // Set up event listeners
                this.setupEventListeners();
                
                // Initialize UI
                this.updatePathDropdown();
                this.updateFramesInputMax();
                
                // Set up global functions for backward compatibility
                this.setupGlobalFunctions();
            }
            
            setupEventListeners() {
                // Playback controls
                this.playPauseBtn.addEventListener('click', () => this.videoController.playPause());
                this.stopBtn.addEventListener('click', () => this.videoController.stop());
                this.frameBackBtn.addEventListener('click', () => this.videoController.stepFrame(-1));
                this.frameForwardBtn.addEventListener('click', () => this.videoController.stepFrame(1));
                
                // Repeat button
                this.repeatBtn.addEventListener('click', () => {
                    this.videoController.state.isLooping = !this.videoController.state.isLooping;
                    this.repeatBtn.classList.toggle('active', this.videoController.state.isLooping);
                    if (this.videoController.state.isLooping && this.video.paused) {
                        this.videoController.seekTo(this.videoController.state.selection.start);
                        this.videoController.play();
                    }
                });
                
                // Selection controls
                document.getElementById('set-in-point').addEventListener('click', () => this.setInPoint());
                document.getElementById('set-out-point').addEventListener('click', () => this.setOutPoint());
                
                // Custom duration inputs
                this.minutesInput.addEventListener('change', () => this.updateSelectionFromPlayhead());
                this.secondsInput.addEventListener('change', () => this.updateSelectionFromPlayhead());
                this.framesInput.addEventListener('change', () => this.updateSelectionFromPlayhead());
                this.playheadPositionSelect.addEventListener('change', () => this.updateSelectionFromPlayhead());
                
                // Reset zoom
                this.resetZoomBtn.addEventListener('click', () => {
                    if (this.video.duration) {
                        this.videoController.setSelection(0, this.video.duration);
                        this.videoController.seekTo(0);
                    }
                });
				
				// Jump to IN/OUT points
				this.jumpToInBtn.addEventListener('click', () => {
					this.videoController.seekTo(this.videoController.state.selection.start);
				});

				this.jumpToOutBtn.addEventListener('click', () => {
					this.videoController.seekTo(this.videoController.state.selection.end);
				});
                
                // File inputs
                this.fileInput.addEventListener('change', e => {
                    if (e.target.files[0]) this.loadVideo(e.target.files[0]);
                    e.target.blur();
                });
                this.jsonInput.addEventListener('change', e => {
                    if (e.target.files[0]) this.handleJSONImport(e.target.files[0]);
                    e.target.blur();
                });
                this.subtitleFileInput.addEventListener('change', e => {
                    this.handleSubtitleSelect(e);
                    e.target.blur();
                });
                
                // Marker controls
                this.addMarkerBtn.addEventListener('click', () => this.addMarker());
                this.saveJsonBtn.addEventListener('click', () => this.saveJSON());
                
                // Search functionality
                this.searchBox.addEventListener('input', () => {
                    this.updateSearchClearButton();
                    this.debounce(this.filterSubtitles.bind(this), 300)();
                });
                this.searchClearBtn.addEventListener('click', () => this.clearSearch());
                this.prevMatchButton.addEventListener('click', () => this.navigateToPreviousMatch());
                this.nextMatchButton.addEventListener('click', () => this.navigateToNextMatch());
                
                // Marker search
                this.markerSearchInput.addEventListener('input', () => {
                    this.updateMarkerSearchClearButton();
                    this.updateMarkersList(this.markerSearchInput.value);
                });
                this.markerSearchClearBtn.addEventListener('click', () => this.clearMarkerSearch());
                
                // Search padding
                this.applySearchPaddingCheckbox.addEventListener('change', () => {
                    this.paddingInfoText.style.display = this.applySearchPaddingCheckbox.checked ? 'inline' : 'none';
                });
                
                // Add search markers button
                const addSearchMarkersBtn = document.getElementById('add-search-markers');
                if (addSearchMarkersBtn) {
                    addSearchMarkersBtn.addEventListener('click', () => this.addSearchResultsAsMarkers());
                }
                
                // Path management
                this.savePathBtn.addEventListener('click', () => {
                    const path = this.customPathInput.value.trim();
                    if (path) this.saveCustomPath(path);
                });
                
                this.savedPathsSelect.addEventListener('change', function() {
                    if (this.value) this.customPathInput.value = this.value;
                }.bind(this));
                
                // Drag and drop
                this.setupDragAndDrop();
                
                // Keyboard shortcuts
                this.setupKeyboardShortcuts();
                
                // Frame rate change
                this.framerateSelect.addEventListener('change', () => {
                    // Clear SMPTE cache when frame rate changes
                    if (this.videoController && this.videoController.smpteCache) {
                        this.videoController.smpteCache.clear();
                    }
                    this.updateFramesInputMax();
                    this.updateMarkersList();
					
			    // Video loaded event - setup edit mode handlers
			    this.video.addEventListener('loadedmetadata', () => {
			        // Render any existing timeline markers
			        this.renderTimelineMarkers();
			        
			        // Setup edit mode handlers after a short delay to ensure waveform is ready
			        setTimeout(() => {
			            if (this.videoController.state.isWaveformReady) {
			                this.setupWaveformEditModeHandlers();
			            }
			        }, 500);
			    });
			    
			    // Also add a waveform ready listener
			    // This ensures edit mode is set up even if waveform loads after video
			    document.addEventListener('waveform-ready', () => {
			        this.setupWaveformEditModeHandlers();
			    });
			}
            
            setupDragAndDrop() {
                const handleDragOver = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.dropZone.classList.add('drag-over');
                };
                
                const handleDragLeave = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.dropZone.classList.remove('drag-over');
                };
                
                const handleDrop = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.dropZone.classList.remove('drag-over');
                    
                    const files = Array.from(e.dataTransfer.files);
                    const videoFiles = files.filter(f => f.type.startsWith('video/'));
                    const subtitleFiles = files.filter(f => f.name.endsWith('.srt') || f.name.endsWith('.vtt') || f.name.endsWith('.txt'));
                    const jsonFiles = files.filter(f => f.name.endsWith('.json'));
                    
                    if (videoFiles.length > 0) this.loadVideo(videoFiles[0]);
                    if (jsonFiles.length > 0) this.handleJSONImport(jsonFiles[0]);
                    if (subtitleFiles.length > 0) this.handleSubtitleFile(subtitleFiles[0]);
                };
                
                this.dropZone.addEventListener('dragover', handleDragOver);
                this.dropZone.addEventListener('dragleave', handleDragLeave);
                this.dropZone.addEventListener('drop', handleDrop);
                
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    document.body.addEventListener(eventName, e => {
                        e.preventDefault();
                        e.stopPropagation();
                    });
                });
            }
            
            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    // Skip if typing in input
                    if (e.target.tagName === 'INPUT' || 
                        e.target.tagName === 'SELECT' || 
                        e.target.tagName === 'TEXTAREA') {
                        return;
                    }
                    
                    // Prevent Enter on buttons
                    if (e.key === 'Enter' && e.target.tagName === 'BUTTON') {
                        e.preventDefault();
                        return;
                    }
                    
                    switch(e.code) {
                        case 'Space':
                            e.preventDefault();
                            e.stopPropagation();
                            if (document.activeElement && document.activeElement.tagName === 'BUTTON') {
                                document.activeElement.blur();
                            }
                            this.videoController.playPause();
                            break;
                            
                        case 'ArrowLeft':
                            if (e.ctrlKey || e.metaKey) {
                                e.preventDefault();
                                this.videoController.stepFrame(-1);
                            }
                            break;
                            
                        case 'ArrowRight':
                            if (e.ctrlKey || e.metaKey) {
                                e.preventDefault();
                                this.videoController.stepFrame(1);
                            }
                            break;
                            
                        case 'KeyI':
                            e.preventDefault();
                            this.setInPoint();
                            break;
                            
                        case 'KeyO':
                            e.preventDefault();
                            this.setOutPoint();
                            break;
                            
                        case 'BracketLeft':
                            e.preventDefault();
                            this.addMarker();
                            break;
							
						case 'KeyX':
						    e.preventDefault();
						    if (this.video.duration) {
							   this.videoController.setSelection(0, this.video.duration);
							   this.videoController.seekTo(0);
						    }
						    break;							
                            
                        case 'KeyQ':
                            e.preventDefault();
                            this.videoController.seekTo(this.videoController.state.selection.start);
                            break;
                            
                        case 'KeyW':
                            e.preventDefault();
                            this.videoController.seekTo(this.videoController.state.selection.end);
                            break;
                            
                        case 'KeyT':
                            e.preventDefault();
                            const tabs = document.querySelectorAll('[data-bs-toggle="tab"]');
                            const activeTab = document.querySelector('.nav-link.active');
                            const activeIndex = Array.from(tabs).indexOf(activeTab);
                            const nextIndex = (activeIndex + 1) % tabs.length;
                            tabs[nextIndex].click();
                            break;
			            // ========================================
			            // ADD THIS NEW CASE FOR ESCAPE KEY
			            // ========================================
			            case 'Escape':
			                e.preventDefault();
			                this.exitMarkerEditMode();
			                // Also clear any text selections
			                if (window.getSelection) {
			                    window.getSelection().removeAllRanges();
			                }
			                // Close any open edit forms
			                const editForms = document.querySelectorAll('.marker-edit-form');
			                editForms.forEach(form => form.remove());
			                break;
			        }
			    });
			}
            
            setupGlobalFunctions() {
                // Global functions for backward compatibility
                window.seekTo = (time) => this.videoController.seekTo(time);
                window.setSelectionRange = (start, end) => this.videoController.setSelection(start, end);
                window.loadMarker = (index) => this.loadMarker(index);
                window.addMarker = () => this.addMarker();
                window.removeMarker = (index) => this.removeMarker(index);
                window.updateCurrentSubtitle = () => this.updateCurrentSubtitle();
                window.updateTimelineScale = () => this.updateTimelineScale();
            }
            
            // ============================================
            // VIDEO LOADING
            // ============================================
            loadVideo(file) {
                if (file && file.type.startsWith('video/')) {
                    if (this.state.currentVideoUrl) {
                        URL.revokeObjectURL(this.state.currentVideoUrl);
                    }
                    
                    this.state.originalFileName = file.name;
                    this.state.originalFilePath = file.path || file.webkitRelativePath || `C:/Videos/${file.name}`;
                    
                    this.state.currentVideoUrl = URL.createObjectURL(file);
                    this.video.src = this.state.currentVideoUrl;
                    
                    // Reset state
                    this.state.audioInfo = { samplerate: null, channelcount: null };
                    this.currentSubtitleDisplay.textContent = '';
                    this.resetWaveform();
                    
                    this.video.onerror = () => {
                        console.error('Error loading video:', this.video.error);
                        alert('Error loading video. Please try another file.');
                    };
                } else {
                    alert('Please upload a valid video file.');
                }
            }
            
            // ============================================
            // SELECTION MANAGEMENT
            // ============================================
            setInPoint() {
                if (!this.video.duration) return;
                const currentTime = this.video.currentTime;
                const { end } = this.videoController.state.selection;
                if (currentTime < end) {
                    this.videoController.setSelection(currentTime, end);
                } else {
                    this.videoController.setSelection(currentTime, currentTime);
                }
            }
            
            setOutPoint() {
                if (!this.video.duration) return;
                const currentTime = this.video.currentTime;
                const { start } = this.videoController.state.selection;
                if (currentTime > start) {
                    this.videoController.setSelection(start, currentTime);
                } else {
                    this.videoController.setSelection(currentTime, currentTime);
                }
            }
            
            updateSelectionFromPlayhead() {
                if (!this.video.duration) return;
                
                const minutes = parseInt(this.minutesInput.value) || 0;
                const seconds = parseInt(this.secondsInput.value) || 0;
                const frames = parseInt(this.framesInput.value) || 0;
                const frameRate = this.videoController.state.frameRate;
                const newDuration = minutes * 60 + seconds + (frames / frameRate);
                
                let newStart, newEnd;
                const currentTime = this.video.currentTime;
                
                switch (this.playheadPositionSelect.value) {
                    case 'in':
                        newStart = currentTime;
                        newEnd = Math.min(this.video.duration, newStart + newDuration);
                        break;
                    case 'out':
                        newEnd = currentTime;
                        newStart = Math.max(0, newEnd - newDuration);
                        break;
                    case 'mid':
                        const halfDuration = newDuration / 2;
                        newStart = Math.max(0, currentTime - halfDuration);
                        newEnd = Math.min(this.video.duration, currentTime + halfDuration);
                        break;
                }
                
                this.videoController.setSelection(newStart, newEnd);
            }
            
            // ============================================
            // MARKER MANAGEMENT
            // ============================================
            addMarker() {
                if (!this.video.duration) return;
                
                const { start, end } = this.videoController.state.selection;
                const frameRate = this.videoController.state.frameRate;
                
                let subtitleText = "";
                let subtitleItems = [];
                
                if (this.state.subtitleFormat === "vtt" && this.state.wordTimings.length > 0) {
                    const wordsInRange = this.state.wordTimings.filter(word => 
                        word.startTime >= start && word.endTime <= end
                    );
                    
                    if (wordsInRange.length > 0) {
                        subtitleText = wordsInRange.map(word => word.text).join(' ');
                        subtitleItems.push({
                            text: subtitleText,
                            start: Math.round(start * frameRate),
                            end: Math.round(end * frameRate)
                        });
                    }
                } else {
                    const overlappingSubtitles = this.state.subtitles.filter(subtitle => 
                        (subtitle.startTime < end && subtitle.endTime > start)
                    );
                    
                    if (overlappingSubtitles.length > 0) {
                        subtitleText = overlappingSubtitles.map(sub => sub.text).join(" ");
                        subtitleItems.push({
                            text: subtitleText,
                            start: Math.round(start * frameRate),
                            end: Math.round(end * frameRate)
                        });
                    }
                }
                
                const newMarker = {
                    start: start,
                    end: end,
                    duration: end - start,
                    comments: subtitleItems
                };
                
                this.videoController.state.markers.push(newMarker);
                this.videoController.state.activeMarkerIndex = this.videoController.state.markers.length - 1;
                this.updateMarkersList();
				this.renderTimelineMarkers();
				this.renderWaveformMarkerRegions();
                
                setTimeout(() => {
                    const newMarkerElement = document.querySelector(`.marker-item[data-index="${this.videoController.state.activeMarkerIndex}"]`);
                    if (newMarkerElement) {
                        newMarkerElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                }, 100);
            }
            
            loadMarker(index) {
                if (!this.video.duration || !this.videoController.state.markers[index]) return;
                
                const marker = this.videoController.state.markers[index];
                this.videoController.setSelection(marker.start, marker.end);
				if (this.videoController.selectionRegion) {
					this.videoController.selectionRegion.update({
						start: marker.start,
						end: marker.end
					});
				}				
                this.videoController.seekTo(marker.start);
                this.videoController.state.activeMarkerIndex = index;
                this.updateMarkersList();
				this.renderTimelineMarkers();
				this.highlightWaveformMarkerRegion(index); // ADD THIS LINE
            }
            
            removeMarker(index) {
                const { markers, activeMarkerIndex } = this.videoController.state;
                
                if (index === activeMarkerIndex) {
                    this.videoController.state.activeMarkerIndex = -1;
                } else if (index < activeMarkerIndex) {
                    this.videoController.state.activeMarkerIndex--;
                }
                
                markers.splice(index, 1);
                this.updateMarkersList();
				this.renderTimelineMarkers();
				this.highlightWaveformMarkerRegion(index); // ADD THIS LINE
            }
            
            updateMarkersList(searchTerm = '') {
                const { markers, activeMarkerIndex, frameRate } = this.videoController.state;
                const lowerCaseSearchTerm = searchTerm.toLowerCase();
                
                const filteredMarkers = markers
                    .map((marker, index) => ({ marker, originalIndex: index }))
                    .filter(({ marker }) => {
                        if (!lowerCaseSearchTerm) return true;
                        const commentObj = marker.comments && marker.comments.length > 0 ? marker.comments[0] : null;
                        const displayText = commentObj ? commentObj.text : "";
                        return displayText.toLowerCase().includes(lowerCaseSearchTerm);
                    });

				this.markersList.innerHTML = markers.length ? '<h5 class="mt-3 mb-2">Markers:</h5>' : '';
				
			    filteredMarkers.forEach(({ marker, originalIndex }) => {
			        const div = document.createElement('div');
			        div.className = 'marker-item';
			        
			        // Add editing class if this marker is being edited
			        if (originalIndex === this.state.editingMarkerIndex) {
			            div.classList.add('editing');
			        }
					
					const div = document.createElement('div');
					div.className = 'marker-item';
					div.setAttribute('data-index', originalIndex);
					
					if (originalIndex === activeMarkerIndex) {
						div.classList.add('active');
					}
					
					const commentObj = marker.comments && marker.comments.length > 0 ? marker.comments[0] : null;
					const displayText = commentObj ? commentObj.text : "";
					
					const headerDiv = document.createElement('div');
					headerDiv.className = 'marker-header';
					headerDiv.innerHTML = `
						<span class="marker-label">Marker ${originalIndex + 1}: ${this.videoController.toSMPTE(marker.start)} - ${this.videoController.toSMPTE(marker.end)} (${this.videoController.toSMPTE(marker.duration)})</span>
						<div class="marker-actions">
							<button class="btn btn-sm btn-primary me-1 load-marker" title="Load this marker">Load</button>
							<button class="btn btn-sm btn-info me-1 edit-marker" title="Edit comment text">Edit</button>
							<button class="btn btn-sm btn-danger remove-marker" title="Remove this marker">X</button>
						</div>
					`;
					div.appendChild(headerDiv);
					
					if (displayText) {
						const commentDiv = document.createElement('div');
						commentDiv.className = 'marker-comment';
						commentDiv.textContent = displayText;
						div.appendChild(commentDiv);
					}
					
					// Event listeners
					headerDiv.querySelector('.marker-label').addEventListener('click', () => {
						this.loadMarker(originalIndex);
					});
					
					headerDiv.querySelector('.load-marker').addEventListener('click', () => {
						this.loadMarker(originalIndex);
					});
					
					headerDiv.querySelector('.edit-marker').addEventListener('click', () => {
						this.editMarkerText(originalIndex, div);
					});
					
					headerDiv.querySelector('.remove-marker').addEventListener('click', () => {
						this.removeMarker(originalIndex);
					});
					
					this.markersList.appendChild(div);
				});
			}                
				
			renderTimelineMarkers() {
				// Remove existing marker regions from timeline
				const existingMarkers = this.mainTimeline.querySelectorAll('.timeline-marker-region');
				existingMarkers.forEach(el => el.remove());
				
				// Skip if no video duration
				if (!this.video.duration) return;
				
				// Add marker regions to timeline
				this.videoController.state.markers.forEach((marker, index) => {
					const startPercent = (marker.start / this.video.duration) * 100;
					const endPercent = (marker.end / this.video.duration) * 100;
					const widthPercent = endPercent - startPercent;
					
					// Create marker region element
					const markerRegion = document.createElement('div');
					markerRegion.className = 'timeline-marker-region';
					markerRegion.dataset.markerIndex = index;
					
					// Apply positioning
					markerRegion.style.left = `${startPercent}%`;
					markerRegion.style.width = `${widthPercent}%`;
					
					// Add active state if this is the active marker
					if (index === this.videoController.state.activeMarkerIndex) {
						markerRegion.classList.add('active');
					}
					
					// Add tooltip with marker info
					const markerNumber = index + 1;
					const tooltipText = `Marker ${markerNumber}: ${this.videoController.toSMPTE(marker.start)} - ${this.videoController.toSMPTE(marker.end)}`;
					markerRegion.title = tooltipText;
					
					// Add click handler to load the marker
					markerRegion.addEventListener('click', (e) => {
						e.stopPropagation(); // Prevent timeline click
						this.loadMarker(index);
					});
					
					// Add hover effect
					markerRegion.addEventListener('mouseenter', () => {
						markerRegion.style.opacity = '0.6';
					});
					
					markerRegion.addEventListener('mouseleave', () => {
						markerRegion.style.opacity = '';
					});
					
					// Append to timeline
					this.mainTimeline.appendChild(markerRegion);
				});
			}
			
			renderWaveformMarkerRegions() {
				// Only proceed if waveform is ready
				if (!this.videoController.state.isWaveformReady || !this.videoController.wavesurfer) {
					return;
				}
				
				// Clear existing marker regions (but keep the selection region)
				if (this.videoController.wavesurfer.regions) {
					const regions = this.videoController.wavesurfer.regions.list;
					Object.keys(regions).forEach(id => {
						const region = regions[id];
						// Only remove regions that are markers (not the main selection)
						if (region.attributes && region.attributes.isMarker) {
							region.remove();
						}
					});
				}
				
				// Add a region for each marker
				this.videoController.state.markers.forEach((marker, index) => {
					const region = this.videoController.wavesurfer.regions.add({
						start: marker.start,
						end: marker.end,
						color: 'rgba(255, 0, 0, 0.2)', // Red with transparency
						drag: true,  // Allow dragging the entire region
						resize: true, // Allow resizing from edges
						attributes: {
							isMarker: true,
							markerIndex: index,
							label: `Marker ${index + 1}`
						}
					});
					
					// Add event listeners for this specific region
					this.attachRegionEventListeners(region, index);
				});
			}
			
			attachRegionEventListeners(region, markerIndex) {
				// Handle region updates (resize or drag)
				region.on('update-end', () => {
					// Update the corresponding marker in our state
					const marker = this.videoController.state.markers[markerIndex];
					if (marker) {
						marker.start = region.start;
						marker.end = region.end;
						marker.duration = region.end - region.start;
						
						// Update the comments timing if they exist
						if (marker.comments && marker.comments.length > 0) {
							const frameRate = this.videoController.state.frameRate;
							marker.comments[0].start = Math.round(marker.start * frameRate);
							marker.comments[0].end = Math.round(marker.end * frameRate);
						}
						
						// Update displays
						this.updateMarkersList();
						this.renderTimelineMarkers();
						
						// If this is the active marker, update the selection
						if (markerIndex === this.videoController.state.activeMarkerIndex) {
							this.videoController.setSelection(region.start, region.end);
						}
					}
				});
				
				// Handle clicks on the region
				region.on('click', (e) => {
					// Load this marker
					this.loadMarker(markerIndex);
					
					// Highlight the region
					this.highlightWaveformMarkerRegion(markerIndex);
				});
				
				// Handle double-click for deletion
				region.on('dblclick', (e) => {
					e.stopPropagation();
					e.preventDefault();
					
					if (confirm(`Delete Marker ${markerIndex + 1}?`)) {
						this.removeMarker(markerIndex);
					}
				});
			}
			
			highlightWaveformMarkerRegion(activeIndex) {
				if (!this.videoController.wavesurfer || !this.videoController.wavesurfer.regions) {
					return;
				}
				
				const regions = this.videoController.wavesurfer.regions.list;
				Object.keys(regions).forEach(id => {
					const region = regions[id];
					if (region.attributes && region.attributes.isMarker) {
						const index = region.attributes.markerIndex;
						if (index === activeIndex) {
							// Highlight active marker
							region.update({ color: 'rgba(255, 0, 0, 0.4)' });
						} else {
							// Reset other markers to normal color
							region.update({ color: 'rgba(255, 0, 0, 0.2)' });
						}
					}
				});
			}
			
			syncWaveformMarkerIndices() {
				if (!this.videoController.wavesurfer || !this.videoController.wavesurfer.regions) {
					return;
				}
				
				// After removing a marker, we need to rebuild all regions
				// because the indices have changed
				this.renderWaveformMarkerRegions();
			}
			
			debugMarkerSync() {
				console.log('=== Marker Sync Debug ===');
				console.log('Markers in state:', this.videoController.state.markers);
				console.log('Marker list items:', document.querySelectorAll('.marker-item').length);
				console.log('Timeline regions:', document.querySelectorAll('.timeline-marker-region').length);
				
				if (this.videoController.wavesurfer && this.videoController.wavesurfer.regions) {
					const waveformRegions = Object.values(this.videoController.wavesurfer.regions.list)
						.filter(r => r.attributes && r.attributes.isMarker);
					console.log('Waveform regions:', waveformRegions.length);
				}
				
				console.log('All counts should match!');
			}
			
			editMarkerText(index, markerElement) {
				// ... existing editMarkerText code ...
				
				// In the save-edit handler:
				editForm.querySelector('.save-edit').addEventListener('click', () => {
					// ... existing save code ...
					
					this.updateMarkersList();
					this.renderTimelineMarkers();
					this.renderWaveformMarkerRegions(); // ADD THIS LINE
				});
			}
			
			// ============================================
			// WAVEFORM MARKER REGIONS MANAGEMENT
			// ============================================

			// Add this method to render marker regions in WaveSurfer
			renderWaveformMarkerRegions() {
				// Only proceed if waveform is ready
				if (!this.videoController.state.isWaveformReady || !this.videoController.wavesurfer) {
					return;
				}
				
				// Clear existing marker regions (but keep the selection region)
				if (this.videoController.wavesurfer.regions) {
					const regions = this.videoController.wavesurfer.regions.list;
					Object.keys(regions).forEach(id => {
						const region = regions[id];
						// Only remove regions that are markers (not the main selection)
						if (region && region.attributes && region.attributes.isMarker === true) {
							region.remove();
						}
					});
				}
				
				// Add a region for each marker
				this.videoController.state.markers.forEach((marker, index) => {
					const region = this.videoController.wavesurfer.regions.add({
						start: marker.start,
						end: marker.end,
						color: 'rgba(255, 0, 0, 0.2)', // Red with transparency
						drag: true,  // Allow dragging the entire region
						resize: true, // Allow resizing from edges
						attributes: {
							isMarker: true,
							markerIndex: index,
							label: `Marker ${index + 1}`
						}
					});
					
					// Add event listeners for this specific region
					this.attachRegionEventListeners(region, index);
				});
			}

			// Method to attach event listeners to a marker region
			attachRegionEventListeners(region, markerIndex) {
				// Handle region updates (resize or drag)
				region.on('update-end', () => {
					// Update the corresponding marker in our state
					const marker = this.videoController.state.markers[markerIndex];
					if (marker) {
						marker.start = region.start;
						marker.end = region.end;
						marker.duration = region.end - region.start;
						
						// Update the comments timing if they exist
						if (marker.comments && marker.comments.length > 0) {
							const frameRate = this.videoController.state.frameRate;
							marker.comments[0].start = Math.round(marker.start * frameRate);
							marker.comments[0].end = Math.round(marker.end * frameRate);
						}
						
						// Update displays
						this.updateMarkersList();
						this.renderTimelineMarkers();
						
						// If this is the active marker, update the selection
						if (markerIndex === this.videoController.state.activeMarkerIndex) {
							this.videoController.setSelection(region.start, region.end);
						}
					}
				});
				
				// Handle clicks on the region
				region.on('click', (e) => {
					// Load this marker
					this.loadMarker(markerIndex);
					
					// Highlight the region
					this.highlightWaveformMarkerRegion(markerIndex);
				});
			}

			// Method to highlight the active marker region in the waveform
			highlightWaveformMarkerRegion(activeIndex) {
				if (!this.videoController.wavesurfer || !this.videoController.wavesurfer.regions) {
					return;
				}
				
				const regions = this.videoController.wavesurfer.regions.list;
				Object.keys(regions).forEach(id => {
					const region = regions[id];
					if (region.attributes && region.attributes.isMarker) {
						const index = region.attributes.markerIndex;
						if (index === activeIndex) {
							// Highlight active marker
							region.update({ color: 'rgba(255, 0, 0, 0.4)' });
						} else {
							// Reset other markers to normal color
							region.update({ color: 'rgba(255, 0, 0, 0.2)' });
						}
					}
				});
			}

			// Method to sync marker indices after deletion
			syncWaveformMarkerIndices() {
				if (!this.videoController.wavesurfer || !this.videoController.wavesurfer.regions) {
					return;
				}
				
				// After removing a marker, we need to rebuild all regions
				// because the indices have changed
				this.renderWaveformMarkerRegions();
			}			

			renderTimelineMarkers() {
				// Remove existing marker regions from timeline
				const existingMarkers = this.mainTimeline.querySelectorAll('.timeline-marker-region');
				existingMarkers.forEach(el => el.remove());
				
				// Skip if no video duration
				if (!this.video.duration) return;
				
				// Add marker regions to timeline
				this.videoController.state.markers.forEach((marker, index) => {
					const startPercent = (marker.start / this.video.duration) * 100;
					const endPercent = (marker.end / this.video.duration) * 100;
					const widthPercent = endPercent - startPercent;
					
					// Create marker region element
					const markerRegion = document.createElement('div');
					markerRegion.className = 'timeline-marker-region';
					markerRegion.dataset.markerIndex = index;
					
					// Apply positioning
					markerRegion.style.left = `${startPercent}%`;
					markerRegion.style.width = `${widthPercent}%`;
					
					// Add active state if this is the active marker
					if (index === this.videoController.state.activeMarkerIndex) {
						markerRegion.classList.add('active');
					}
					
					// Add tooltip with marker info
					const markerNumber = index + 1;
					const tooltipText = `Marker ${markerNumber}: ${this.videoController.toSMPTE(marker.start)} - ${this.videoController.toSMPTE(marker.end)}`;
					markerRegion.title = tooltipText;
					
					// Add click handler to load the marker
					markerRegion.addEventListener('click', (e) => {
						e.stopPropagation(); // Prevent timeline click
						this.loadMarker(index);
					});
					
					// Add hover effect
					markerRegion.addEventListener('mouseenter', () => {
						markerRegion.style.opacity = '0.6';
					});
					
					markerRegion.addEventListener('mouseleave', () => {
						markerRegion.style.opacity = '';
					});
					
					// Append to timeline
					this.mainTimeline.appendChild(markerRegion);
				});
			}		
            
            editMarkerText(index, markerElement) {
                const marker = this.videoController.state.markers[index];
                
                const existingForm = markerElement.querySelector('.marker-edit-form');
                if (existingForm) {
                    markerElement.removeChild(existingForm);
                    return;
                }
                
                const commentObj = marker.comments && marker.comments.length > 0 ? marker.comments[0] : null;
                const currentText = commentObj ? commentObj.text : "";
                
                const editForm = document.createElement('div');
                editForm.className = 'marker-edit-form mt-2 w-100';
                editForm.innerHTML = `
                    <div class="mb-2">
                        <label for="marker-text-${index}" class="form-label small">Comment Text</label>
                        <textarea class="form-control form-control-sm" id="marker-text-${index}" rows="3" placeholder="Enter comment text...">${currentText}</textarea>
                    </div>
                    <div class="d-flex justify-content-end">
                        <button class="btn btn-sm btn-secondary me-2 cancel-edit">Cancel</button>
                        <button class="btn btn-sm btn-primary save-edit">Save Changes</button>
                    </div>
                `;
                
                markerElement.appendChild(editForm);
                
                const textArea = document.getElementById(`marker-text-${index}`);
                textArea.focus();
                textArea.setSelectionRange(textArea.value.length, textArea.value.length);
                
                editForm.querySelector('.cancel-edit').addEventListener('click', () => {
                    markerElement.removeChild(editForm);
                });
                
                editForm.querySelector('.save-edit').addEventListener('click', () => {
                    const newText = document.getElementById(`marker-text-${index}`).value;
                    const frameRate = this.videoController.state.frameRate;
                    
                    if (newText.trim()) {
                        if (marker.comments && marker.comments.length > 0) {
                            marker.comments[0].text = newText;
                        } else {
                            marker.comments = [{
                                text: newText,
                                start: Math.round(marker.start * frameRate),
                                end: Math.round(marker.end * frameRate)
                            }];
                        }
                    } else {
                        marker.comments = [];
                    }
                    
                    this.updateMarkersList();
					this.renderTimelineMarkers();
					this.renderWaveformMarkerRegions(); // ADD THIS LINE
                });
            }
            
            // ============================================
            // SUBTITLE HANDLING
            // ============================================
            handleSubtitleSelect(event) {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const content = e.target.result;
                        
                        if (file.name.endsWith('.vtt')) {
                            this.state.subtitleFormat = "vtt";
                            window.originalVttContent = content;
                            this.state.subtitles = this.parseWebVTT(content);
                            this.state.wordTimings = this.extractWordTimings(content);
                            this.renderTranscript(content);
                        } else {
                            this.state.subtitleFormat = "srt";
                            window.originalSrtContent = content;
                            this.state.subtitles = this.parseSRT(content);
                            this.renderSubtitleList(this.state.subtitles);
                        }
                        
                        document.getElementById('transcript-tab').click();
                    };
                    reader.readAsText(file);
                }
            }
            
            handleSubtitleFile(file) {
                if (file) {
                    const dataTransfer = new DataTransfer();
                    dataTransfer.items.add(file);
                    this.subtitleFileInput.files = dataTransfer.files;
                    const event = new Event('change', { bubbles: true });
                    this.subtitleFileInput.dispatchEvent(event);
                }
            }
            
            parseSRT(srtContent) {
                const srtItems = [];
                const subtitleBlocks = srtContent.trim().split(/\r?\n\r?\n/);
                
                subtitleBlocks.forEach(block => {
                    const lines = block.split(/\r?\n/);
                    if (lines.length < 3) return;
                    
                    const timeRange = lines[1];
                    const timeMatch = timeRange.match(/(\d{2}:\d{2}:\d{2},\d{3}) --> (\d{2}:\d{2}:\d{2},\d{3})/);
                    
                    if (!timeMatch) return;
                    
                    const startTime = this.timeToSeconds(timeMatch[1]);
                    const endTime = this.timeToSeconds(timeMatch[2]);
                    const textLines = lines.slice(2);
                    const text = textLines.join(' ').trim();
                    
                    srtItems.push({
                        startTime,
                        endTime,
                        text,
                        startTimeString: this.formatTimeForDisplay(startTime)
                    });
                });
                
                return srtItems;
            }
            
            parseWebVTT(vttContent) {
                const vttItems = [];
                const lines = vttContent.split(/\r?\n/);
                
                let inCue = false;
                let currentCueStart = 0;
                let currentCueEnd = 0;
                let currentCueText = "";
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    
                    if (!line || line === 'WEBVTT') continue;
                    
                    if (line.includes('-->')) {
                        if (inCue && currentCueText) {
                            vttItems.push({
                                startTime: currentCueStart,
                                endTime: currentCueEnd,
                                text: currentCueText.trim(),
                                startTimeString: this.formatTimeForDisplay(currentCueStart)
                            });
                        }
                        
                        inCue = true;
                        currentCueText = "";
                        const timestamps = line.split('-->').map(t => t.trim());
                        currentCueStart = this.parseTimestamp(timestamps[0]);
                        currentCueEnd = this.parseTimestamp(timestamps[1]);
                        continue;
                    }
                    
                    if (/^\d+$/.test(line)) continue;
                    
                    if (inCue && line) {
                        const cleanLine = line.replace(/<\d\d:\d\d:\d\d\.\d\d\d>|<\/\d\d:\d\d:\d\d\.\d\d\d>/g, '');
                        currentCueText += (currentCueText ? " " : "") + cleanLine;
                    }
                }
                
                if (inCue && currentCueText) {
                    vttItems.push({
                        startTime: currentCueStart,
                        endTime: currentCueEnd,
                        text: currentCueText.trim(),
                        startTimeString: this.formatTimeForDisplay(currentCueStart)
                    });
                }
                
                return vttItems;
            }
            
            extractWordTimings(vttContent) {
                const words = [];
                const lines = vttContent.split(/\r?\n/);
                
                for (const line of lines) {
                    const wordMatches = line.matchAll(/<(\d{2}:\d{2}:\d{2}\.\d{3})>([^<]+)<\/?(\d{2}:\d{2}:\d{2}\.\d{3})>/g);
                    
                    for (const match of wordMatches) {
                        const startTime = this.parseTimestamp(match[1]);
                        const text = match[2].trim();
                        const endTime = this.parseTimestamp(match[3]);
                        
                        if (text) {
                            words.push({ text, startTime, endTime });
                        }
                    }
                }
                
                return words;
            }
            
            renderSubtitleList(subtitlesToRender) {
                this.subtitleList.innerHTML = '';
                
                if (subtitlesToRender.length === 0) {
                    this.subtitleList.innerHTML = '<p class="info-text">No subtitles found or match your search.</p>';
                    return;
                }
                
                subtitlesToRender.forEach((subtitle, index) => {
                    const subtitleItem = document.createElement('div');
                    subtitleItem.className = 'subtitle-item';
                    subtitleItem.dataset.index = index;
                    subtitleItem.dataset.startTime = subtitle.startTime;
                    subtitleItem.dataset.endTime = subtitle.endTime;
                    
                    subtitleItem.innerHTML = `
                        <div class="d-flex justify-content-between align-items-center">
                            <span class="time-stamp">${subtitle.startTimeString}</span>
                            <button class="create-marker-from-subtitle" title="Create marker from this subtitle">+</button>
                        </div>
                        <span class="subtitle-text">${subtitle.text}</span>
                    `;
                    
                    subtitleItem.addEventListener('click', (e) => {
                        if (e.target.classList.contains('create-marker-from-subtitle')) return;
                        
                        const allItems = this.subtitleList.querySelectorAll('.subtitle-item');
                        allItems.forEach(item => item.classList.remove('active'));
                        subtitleItem.classList.add('active');
                        
                        this.videoController.setSelection(subtitle.startTime, subtitle.endTime);
                        this.videoController.seekTo(subtitle.startTime);
                        this.video.pause();
                    });
                    
                    subtitleItem.querySelector('.create-marker-from-subtitle').addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.createMarkerFromSubtitle(subtitle);
                    });
                    
                    this.subtitleList.appendChild(subtitleItem);
                });
            }
            
            renderTranscript(vttContent) {
                this.subtitleList.innerHTML = '';
                
                if (this.state.wordTimings.length === 0) {
                    this.renderSubtitleList(this.state.subtitles);
                    return;
                }
                
                const transcriptContainer = document.createElement('div');
                transcriptContainer.className = 'json-transcript';
                
                let currentSegmentIndex = 0;
                let segmentContainer = document.createElement('div');
                segmentContainer.className = 'transcript-segment';
                segmentContainer.dataset.index = currentSegmentIndex;
                
                if (this.state.subtitles.length > 0) {
                    segmentContainer.dataset.startTime = this.state.subtitles[0].startTime;
                    segmentContainer.dataset.endTime = this.state.subtitles[0].endTime;
                    
                    const timeStamp = document.createElement('span');
                    timeStamp.className = 'time-stamp';
                    timeStamp.textContent = this.formatTimeForDisplay(this.state.subtitles[0].startTime);
                    segmentContainer.appendChild(timeStamp);
                    
                    const createMarkerBtn = document.createElement('button');
                    createMarkerBtn.className = 'create-marker-from-subtitle float-end';
                    createMarkerBtn.title = 'Create marker from this segment';
                    createMarkerBtn.textContent = '+';
                    createMarkerBtn.dataset.segmentIndex = '0';
                    createMarkerBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const segmentIndex = parseInt(createMarkerBtn.dataset.segmentIndex);
                        this.createMarkerFromSubtitle(this.state.subtitles[segmentIndex]);
                    });
                    segmentContainer.appendChild(createMarkerBtn);
                }
                
                this.state.wordTimings.forEach((word, index) => {
                    while (currentSegmentIndex < this.state.subtitles.length - 1 && 
                            word.startTime >= this.state.subtitles[currentSegmentIndex + 1].startTime) {
                        transcriptContainer.appendChild(segmentContainer);
                        
                        currentSegmentIndex++;
                        segmentContainer = document.createElement('div');
                        segmentContainer.className = 'transcript-segment';
                        segmentContainer.dataset.index = currentSegmentIndex;
                        segmentContainer.dataset.startTime = this.state.subtitles[currentSegmentIndex].startTime;
                        segmentContainer.dataset.endTime = this.state.subtitles[currentSegmentIndex].endTime;
                        
                        const timeStamp = document.createElement('span');
                        timeStamp.className = 'time-stamp';
                        timeStamp.textContent = this.formatTimeForDisplay(this.state.subtitles[currentSegmentIndex].startTime);
                        segmentContainer.appendChild(timeStamp);
                        
                        const createMarkerBtn = document.createElement('button');
                        createMarkerBtn.className = 'create-marker-from-subtitle float-end';
                        createMarkerBtn.title = 'Create marker from this segment';
                        createMarkerBtn.textContent = '+';
                        createMarkerBtn.dataset.segmentIndex = currentSegmentIndex.toString();
                        createMarkerBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const segmentIndex = parseInt(e.target.dataset.segmentIndex);
                            this.createMarkerFromSubtitle(this.state.subtitles[segmentIndex]);
                        });
                        segmentContainer.appendChild(createMarkerBtn);
                    }
                    
                    const wordSpan = document.createElement('span');
                    wordSpan.className = 'transcript-word';
                    wordSpan.textContent = word.text;
                    wordSpan.dataset.start = word.startTime;
                    wordSpan.dataset.end = word.endTime;
                    
                    wordSpan.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.videoController.setSelection(word.startTime, word.endTime);
                        this.videoController.seekTo(word.startTime);
                        this.video.pause();
                    });
                    
                    segmentContainer.appendChild(wordSpan);
                    
                    if (index < this.state.wordTimings.length - 1) {
                        segmentContainer.appendChild(document.createTextNode(' '));
                    }
                });
                
                transcriptContainer.querySelectorAll('.transcript-segment').forEach(seg => {
                    seg.addEventListener('click', (e) => {
                        if (e.target.classList.contains('transcript-word') || 
                            e.target.classList.contains('create-marker-from-subtitle')) return;
                        
                        const start = parseFloat(seg.dataset.startTime);
                        const end = parseFloat(seg.dataset.endTime);
                        this.videoController.setSelection(start, end);
                        this.videoController.seekTo(start);
                        this.video.pause();
                    });
                });
                
                if (segmentContainer.childNodes.length > 0) {
                    transcriptContainer.appendChild(segmentContainer);
                }
                
                this.subtitleList.appendChild(transcriptContainer);
            }
            
            updateCurrentSubtitle() {
                if (!this.state.subtitles.length) return;
                
                const currentTime = this.video.currentTime;
                const index = this.state.subtitles.findIndex(sub => 
                    currentTime >= sub.startTime && currentTime <= sub.endTime
                );
                
                if (index !== this.state.currentSubtitleIndex) {
                    this.state.currentSubtitleIndex = index;
                    const activeItems = this.subtitleList.querySelectorAll('.active');
                    activeItems.forEach(item => item.classList.remove('active'));
                    
                    if (index !== -1) {
                        const currentSubtitle = this.state.subtitles[index];
                        if (this.state.subtitleFormat === "vtt" && this.state.wordTimings.length > 0) {
                            const wordsInCue = this.state.wordTimings.filter(w => 
                                w.startTime >= currentSubtitle.startTime && w.endTime <= currentSubtitle.endTime
                            );
                            let subtitleHTML = "";
                            wordsInCue.forEach(word => {
                                const isActive = currentTime >= word.startTime && currentTime <= word.endTime;
                                subtitleHTML += `<span class="video-subtitle-word ${isActive ? 'word-active' : ''}" data-start="${word.startTime}">${word.text}</span> `;
                            });
                            this.currentSubtitleDisplay.innerHTML = subtitleHTML.trim();
                        } else {
                            this.currentSubtitleDisplay.textContent = currentSubtitle.text;
                        }
                        
                        const elementToActivate = this.subtitleList.querySelector(`[data-index='${index}']`);
                        if (elementToActivate) {
                            elementToActivate.classList.add('active');
                            if (!this.video.paused || document.activeElement !== this.video) {
                                this.scrollElementIntoViewIfNeeded(elementToActivate, this.subtitleList);
                            }
                        }
                        
                        if (this.state.subtitleFormat === "vtt") {
                            this.updateCurrentWord(currentTime);
                        }
                    } else {
                        this.currentSubtitleDisplay.textContent = '';
                    }
                } else if (this.state.subtitleFormat === "vtt" && index !== -1) {
                    const currentWords = this.currentSubtitleDisplay.querySelectorAll('.video-subtitle-word');
                    currentWords.forEach(word => {
                        const start = parseFloat(word.dataset.start);
                        const isActive = currentTime >= start && currentTime <= (start + 0.5);
                        word.classList.toggle('word-active', isActive);
                    });
                    
                    this.updateCurrentWord(currentTime);
                }
            }
            
            updateCurrentWord(currentTime) {
                const activeWords = this.subtitleList.querySelectorAll('.word-active');
                activeWords.forEach(word => word.classList.remove('word-active'));
                
                const words = this.subtitleList.querySelectorAll('.transcript-word');
                let activeWordFound = false;
                
                words.forEach(word => {
                    const start = parseFloat(word.dataset.start);
                    const end = parseFloat(word.dataset.end);
                    
                    if (currentTime >= start && currentTime <= end) {
                        word.classList.add('word-active');
                        activeWordFound = true;
                        
                        const isPlaying = !this.video.paused;
                        if (!isPlaying || document.activeElement !== this.video) {
                            this.scrollElementIntoViewIfNeeded(word, this.subtitleList);
                        }
                    }
                });
                
                return activeWordFound;
            }
            
            createMarkerFromSubtitle(subtitle) {
                if (!this.video.duration) return;
                
                this.videoController.setSelection(subtitle.startTime, subtitle.endTime);
                
                const frameRate = this.videoController.state.frameRate;
                const newMarker = {
                    start: subtitle.startTime,
                    end: subtitle.endTime,
                    duration: subtitle.endTime - subtitle.startTime,
                    comments: [{
                        text: subtitle.text,
                        start: Math.round(subtitle.startTime * frameRate),
                        end: Math.round(subtitle.endTime * frameRate)
                    }]
                };
                
                this.videoController.state.markers.push(newMarker);
			    this.videoController.state.markers.push(newMarker);
			    
			    // Sort markers after adding
			    this.sortMarkers();
			    
			    // Find the new marker's index after sorting
			    const newMarkerIndex = this.videoController.state.markers.findIndex(m => 
			        m.start === newMarker.start && m.end === newMarker.end
			    );
			    
			    this.videoController.state.activeMarkerIndex = newMarkerIndex;
			    
			    // Don't need to call update methods - sortMarkers() does it
			    document.getElementById('markers-tab').click();
			}
            
            // ============================================
            // SEARCH FUNCTIONALITY
            // ============================================
            filterSubtitles() {
                const searchTerm = this.searchBox.value.toLowerCase().trim();
                
                // Reset highlights
                document.querySelectorAll('.search-match, .current-match').forEach(el => {
                    el.classList.remove('search-match', 'current-match');
                    const originalText = el.dataset.originalText;
                    if (originalText) {
                        el.innerHTML = originalText;
                    }
                });
                
                this.state.searchMatches = [];
                this.state.currentMatchIndex = -1;
                this.updateSearchResultsUI();
                
                if (!searchTerm) {
                    if (this.state.subtitleFormat === "vtt") {
                        this.subtitleList.querySelectorAll('.transcript-word').forEach(word => {
                            word.classList.remove('search-match', 'current-match');
                        });
                    }
                    return;
                }
                
                let matchesFound = [];
                
                if (this.state.subtitleFormat === 'vtt' && this.state.wordTimings.length > 0) {
                    const allWords = Array.from(this.subtitleList.querySelectorAll('.transcript-word'));
                    const searchWords = searchTerm.split(/\s+/);
                    
                    for (let i = 0; i <= allWords.length - searchWords.length; i++) {
                        let potentialMatch = [];
                        let fullMatch = true;
                        
                        for (let j = 0; j < searchWords.length; j++) {
                            const wordElement = allWords[i + j];
                            const wordText = wordElement.textContent.toLowerCase();
                            if (wordText.includes(searchWords[j])) {
                                potentialMatch.push(wordElement);
                            } else {
                                fullMatch = false;
                                break;
                            }
                        }
                        
                        if (fullMatch) {
                            let isContiguous = true;
                            for (let k = 0; k < potentialMatch.length - 1; k++) {
                                const end = parseFloat(potentialMatch[k].dataset.end);
                                const start = parseFloat(potentialMatch[k+1].dataset.start);
                                if (start - end > 1.0) {
                                    isContiguous = false;
                                    break;
                                }
                            }
                            
                            if(isContiguous) {
                                matchesFound.push(potentialMatch);
                                i += potentialMatch.length - 1;
                            }
                        }
                    }
                    
                    matchesFound.forEach(phrase => phrase.forEach(word => word.classList.add('search-match')));
                } else {
                    const items = this.subtitleList.querySelectorAll('.subtitle-item, .transcript-segment');
                    items.forEach(item => {
                        const textElement = item.querySelector('.subtitle-text') || item;
                        const originalText = textElement.textContent;
                        if (originalText.toLowerCase().includes(searchTerm)) {
                            if(item.classList.contains('subtitle-item')) {
                                const regex = new RegExp(`(${searchTerm.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')})`, 'gi');
                                textElement.dataset.originalText = originalText;
                                textElement.innerHTML = originalText.replace(regex, '<span class="search-match">$1</span>');
                            } else {
                                item.classList.add('search-match');
                            }
                            matchesFound.push(item);
                        }
                    });
                }
                
                if (matchesFound.length > 0) {
                    this.state.searchMatches = matchesFound;
                    this.state.currentMatchIndex = 0;
                    this.highlightCurrentMatch();
                }
                
                this.updateSearchResultsUI();
            }
            
            navigateToPreviousMatch() {
                if (this.state.searchMatches.length === 0) return;
                this.state.currentMatchIndex = (this.state.currentMatchIndex > 0) 
                    ? this.state.currentMatchIndex - 1 
                    : this.state.searchMatches.length - 1;
                this.highlightCurrentMatch();
            }
            
            navigateToNextMatch() {
                if (this.state.searchMatches.length === 0) return;
                this.state.currentMatchIndex = (this.state.currentMatchIndex < this.state.searchMatches.length - 1) 
                    ? this.state.currentMatchIndex + 1 
                    : 0;
                this.highlightCurrentMatch();
            }
            
            highlightCurrentMatch() {
                document.querySelectorAll('.current-match').forEach(el => el.classList.remove('current-match'));
                
                if (this.state.searchMatches.length === 0 || this.state.currentMatchIndex === -1) return;
                
                const currentMatch = this.state.searchMatches[this.state.currentMatchIndex];
                let firstElement;
                let selectionStart, selectionEnd;
                
                if (Array.isArray(currentMatch)) {
                    currentMatch.forEach(el => el.classList.add('current-match'));
                    firstElement = currentMatch[0];
                    selectionStart = parseFloat(firstElement.dataset.start);
                    selectionEnd = parseFloat(currentMatch[currentMatch.length - 1].dataset.end);
                } else {
                    currentMatch.classList.add('current-match');
                    firstElement = currentMatch;
                    if (firstElement.classList.contains('transcript-word')) {
                        selectionStart = parseFloat(firstElement.dataset.start);
                        selectionEnd = parseFloat(firstElement.dataset.end);
                    } else {
                        const index = parseInt(firstElement.dataset.index);
                        if (!isNaN(index) && this.state.subtitles[index]) {
                            selectionStart = this.state.subtitles[index].startTime;
                            selectionEnd = this.state.subtitles[index].endTime;
                        }
                    }
                }
                
                if (firstElement) {
                    this.scrollElementIntoViewIfNeeded(firstElement, this.subtitleList);
                }
                
                if(selectionStart !== undefined && selectionEnd !== undefined) {
                    this.videoController.setSelection(selectionStart, selectionEnd);
                }
                
                this.updateSearchResultsUI();
            }
            
            addSearchResultsAsMarkers() {
                if (!this.state.searchMatches.length || !this.video.duration) {
                    alert('No search results found or video not loaded.');
                    return;
                }
                
                const applyPadding = this.applySearchPaddingCheckbox.checked;
                let paddingDuration = 0;
                let paddingMode = 'mid';
                
                if (applyPadding) {
                    const minutes = parseInt(this.minutesInput.value) || 0;
                    const seconds = parseInt(this.secondsInput.value) || 0;
                    const frames = parseInt(this.framesInput.value) || 0;
                    const frameRate = this.videoController.state.frameRate;
                    paddingDuration = minutes * 60 + seconds + (frames / frameRate);
                    paddingMode = this.playheadPositionSelect.value;
                    
                    if(paddingDuration <= 0) {
                        alert("Please set a positive duration in the 'Precise Range Duration' controls to use for padding.");
                        return;
                    }
                }
                
                let newMarkersCount = 0;
                const frameRate = this.videoController.state.frameRate;
                
                this.state.searchMatches.forEach(match => {
                    let originalStart, originalEnd, text;
                    
                    if(Array.isArray(match)) {
                        originalStart = parseFloat(match[0].dataset.start);
                        originalEnd = parseFloat(match[match.length-1].dataset.end);
                        text = match.map(el => el.textContent).join(' ');
                    } else {
                        const index = parseInt(match.dataset.index);
                        if(!isNaN(index) && this.state.subtitles[index]) {
                            const sub = this.state.subtitles[index];
                            originalStart = sub.startTime;
                            originalEnd = sub.endTime;
                            text = sub.text;
                        }
                    }
                    
                    if(originalStart !== undefined) {
                        let finalStart = originalStart;
                        let finalEnd = originalEnd;
                        
                        if (applyPadding) {
                            switch (paddingMode) {
                                case 'in':
                                    finalStart = originalStart;
                                    finalEnd = originalStart + paddingDuration;
                                    break;
                                case 'out':
                                    finalEnd = originalEnd;
                                    finalStart = originalEnd - paddingDuration;
                                    break;
                                case 'mid':
                                    const midpoint = originalStart + (originalEnd - originalStart) / 2;
                                    finalStart = midpoint - (paddingDuration / 2);
                                    finalEnd = midpoint + (paddingDuration / 2);
                                    break;
                            }
                        }
                        
                        finalStart = Math.max(0, finalStart);
                        finalEnd = Math.min(this.video.duration, finalEnd);
                        
                        if (finalStart < finalEnd) {
                            this.videoController.state.markers.push({
                                start: finalStart,
                                end: finalEnd,
                                duration: finalEnd - finalStart,
                                comments: [{
                                    text: text,
                                    start: Math.round(finalStart * frameRate),
                                    end: Math.round(finalEnd * frameRate)
                                }]
                            });
                            newMarkersCount++;
                        }
                    }
                });
                
			    if (newMarkersCount > 0) {
			        // Sort all markers after bulk add
			        this.sortMarkers();
			        document.getElementById('markers-tab').click();
			        alert(`Added ${newMarkersCount} new markers from search results.`);
			    }
			}
            
            updateSearchResultsUI() {
                const hasMatches = this.state.searchMatches.length > 0;
                
                this.searchNavigation.style.display = hasMatches ? 'flex' : 'none';
                
                const addMarkersBtn = document.getElementById('add-search-markers');
                if (addMarkersBtn) {
                    addMarkersBtn.style.display = hasMatches ? 'block' : 'none';
                }
                
                if (hasMatches) {
                    document.getElementById('search-count').textContent = 
                        `${this.state.currentMatchIndex + 1} of ${this.state.searchMatches.length}`;
                } else {
                    document.getElementById('search-count').textContent = `0 results`;
                }
            }
            
            updateSearchClearButton() {
                this.searchClearBtn.style.display = this.searchBox.value.trim() ? 'block' : 'none';
            }
            
            clearSearch() {
                this.searchBox.value = '';
                this.updateSearchClearButton();
                this.filterSubtitles();
            }
            
            updateMarkerSearchClearButton() {
                this.markerSearchClearBtn.style.display = this.markerSearchInput.value.trim() ? 'block' : 'none';
            }
            
            clearMarkerSearch() {
                this.markerSearchInput.value = '';
                this.updateMarkerSearchClearButton();
                this.updateMarkersList();
            }
            
            // ============================================
            // JSON HANDLING
            // ============================================
            async handleJSONImport(file) {
                try {
                    const text = await file.text();
                    const jsonData = JSON.parse(text);
                    
                    if (jsonData.video && jsonData.clips) {
                        if (jsonData.video.file.media.video.timecode.rate.timebase) {
                            const jsonFrameRate = parseFloat(jsonData.video.file.media.video.timecode.rate.timebase);
                            this.framerateSelect.value = jsonFrameRate.toString();
                            this.videoController.state.frameRate = jsonFrameRate;
                        }
                        
                        this.videoController.state.markers = jsonData.clips.map(clip => ({
                            start: clip.start / this.videoController.state.frameRate,
                            end: clip.end / this.videoController.state.frameRate,
                            duration: (clip.end - clip.start) / this.videoController.state.frameRate,
                            comments: clip.comments || []
                        }));
                        
						this.sortMarkers(); // ADD THIS LINE                      
						this.updateMarkersList();
						this.renderTimelineMarkers();
						this.renderWaveformMarkerRegions(); // ADD THIS LINE
                        
                        if (jsonData.waveform) {
                            this.state.importedWaveformData = jsonData.waveform;
                            this.videoController.initWaveform(jsonData.waveform);
                        }
                    } else {
                        throw new Error('Invalid JSON format. Expected a project file with video and clips data.');
                    }
                } catch (error) {
                    console.error('Error importing JSON:', error);
                    alert('Error importing project file. Please check the file format.');
                }
            }
            
            async saveJSON() {
                if (!this.video.duration) {
                    alert('Please load a video first.');
                    return;
                }
                
                if (!this.state.audioInfo.samplerate) {
                    this.state.audioInfo = await this.detectAudioInfo(this.video);
                }
                
                const customPath = this.customPathInput.value.trim();
                if (customPath) this.saveCustomPath(customPath);
                const pathUrl = customPath || `C:/Videos/`;
                
                const frameRate = this.videoController.state.frameRate;
                const videoData = {
                    "sequence": { "name": this.state.originalFileName.split('.')[0] },
                    "video": {
                        "file": {
                            "name": this.state.originalFileName,
                            "pathurl": pathUrl + this.state.originalFileName,
                            "media": {
                                "video": {
                                    "duration": Math.round(this.video.duration * frameRate),
                                    "timecode": {
                                        "rate": {
                                            "ntsc": [29.97, 59.94, 23.976].includes(frameRate) ? "TRUE" : "FALSE",
                                            "timebase": frameRate
                                        },
                                        "displayformat": "NDF",
                                        "first_timecode": "00:00:00:00"
                                    },
                                    "samplecharacteristics": {
                                        "width": this.video.videoWidth,
                                        "height": this.video.videoHeight,
                                        "anamorphic": "FALSE",
                                        "pixelaspectratio": "Square"
                                    }
                                },
                                "audio": {
                                    "samplecharacteristics": {
                                        "depth": 16,
                                        "samplerate": this.state.audioInfo.samplerate.toString()
                                    },
                                    "channelcount": this.state.audioInfo.channelcount
                                }
                            }
                        }
                    },
                    "clips": this.videoController.state.markers.map((marker, index) => ({
                        "id": (index + 1).toString(),
                        "start": Math.round(marker.start * frameRate),
                        "end": Math.round(marker.end * frameRate),
                        "comments": marker.comments ? marker.comments.map(sub => ({
                            text: sub.text,
                            start: Math.round(marker.start * frameRate),
                            end: Math.round(marker.end * frameRate)
                        })) : []
                    }))
                };
                
                if (this.state.importedWaveformData) {
                    videoData.waveform = this.state.importedWaveformData;
                }
                
                const blob = new Blob([JSON.stringify(videoData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${this.state.originalFileName.split('.')[0]}-project.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            // ============================================
            // UTILITY FUNCTIONS
            // ============================================
            timeToSeconds(timeString) {
                if (typeof timeString === 'number') return timeString;
                
                if (timeString.includes(',')) {
                    const [time, milliseconds] = timeString.split(',');
                    const [hours, minutes, seconds] = time.split(':').map(Number);
                    return hours * 3600 + minutes * 60 + seconds + parseInt(milliseconds) / 1000;
                }
                
                return this.parseTimestamp(timeString);
            }
            
            parseTimestamp(timestamp) {
                const match = timestamp.match(/(\d+):(\d+):(\d+)\.(\d+)/);
                if (match) {
                    const hours = parseInt(match[1], 10);
                    const minutes = parseInt(match[2], 10);
                    const seconds = parseInt(match[3], 10);
                    const milliseconds = parseInt(match[4], 10);
                    return hours * 3600 + minutes * 60 + seconds + milliseconds / 1000;
                }
                
                const shortMatch = timestamp.match(/(\d+):(\d+)\.(\d+)/);
                if (shortMatch) {
                    const minutes = parseInt(shortMatch[1], 10);
                    const seconds = parseInt(shortMatch[2], 10);
                    const milliseconds = parseInt(shortMatch[3], 10);
                    return minutes * 60 + seconds + milliseconds / 1000;
                }
                
                return 0;
            }
            
            formatTimeForDisplay(timeInSeconds) {
                const minutes = Math.floor(timeInSeconds / 60);
                const seconds = Math.floor(timeInSeconds % 60);
                return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            
            scrollElementIntoViewIfNeeded(element, container) {
                // Skip if element is already in view (quick check)
                if (!element || !container) return;
                
                // Use simpler calculation
                const containerHeight = container.clientHeight;
                const scrollTop = container.scrollTop;
                const elementTop = element.offsetTop - container.offsetTop;
                const elementHeight = element.offsetHeight;
                
                const isAbove = elementTop < scrollTop;
                const isBelow = (elementTop + elementHeight) > (scrollTop + containerHeight);
                
                if (isAbove || isBelow) {
                    const targetScroll = elementTop - (containerHeight / 2) + (elementHeight / 2);
                    container.scrollTo({
                        top: targetScroll,
                        behavior: 'smooth'
                    });
                }
            }
            
            debounce(func, wait) {
                let timeout;
                return function(...args) {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(this, args), wait);
                };
            }
            
            updateFramesInputMax() {
                const frameRate = this.videoController.state.frameRate;
                const maxFrames = Math.ceil(frameRate);
                this.framesInput.max = maxFrames - 1;
                this.framesInput.placeholder = `0-${maxFrames - 1}`;
                if (parseInt(this.framesInput.value) >= maxFrames) {
                    this.framesInput.value = 0;
                }
            }
            
            updatePathDropdown() {
                const savedPaths = JSON.parse(localStorage.getItem('customPaths') || '[]');
                
                while (this.savedPathsSelect.options.length > 1) {
                    this.savedPathsSelect.remove(1);
                }
                
                savedPaths.forEach(path => {
                    const option = document.createElement('option');
                    option.value = path;
                    option.textContent = path;
                    this.savedPathsSelect.appendChild(option);
                });
            }
            
            saveCustomPath(path) {
                const savedPaths = JSON.parse(localStorage.getItem('customPaths') || '[]');
                const existingIndex = savedPaths.indexOf(path);
                if (existingIndex !== -1) savedPaths.splice(existingIndex, 1);
                savedPaths.unshift(path);
                if (savedPaths.length > 5) savedPaths.pop();
                localStorage.setItem('customPaths', JSON.stringify(savedPaths));
                this.updatePathDropdown();
            }
            
            updateTimelineScale() {
                const timelineScale = document.getElementById('timeline-scale');
                if (!this.video.duration || !timelineScale) return;
                
                timelineScale.innerHTML = '';
                const viewDuration = this.video.duration;
                const frameRate = this.videoController.state.frameRate;
                
                let interval;
                const containerWidth = this.mainTimeline.offsetWidth;
                const minSpacing = 80;
                
                if (viewDuration <= 10) interval = 1;
                else if (viewDuration <= 60) interval = 5;
                else if (viewDuration <= 300) interval = 15;
                else if (viewDuration <= 900) interval = 30;
                else if (viewDuration <= 1800) interval = 60;
                else if (viewDuration <= 3600) interval = 120;
                else if (viewDuration <= 7200) interval = 300;
                else interval = 600;
                
                const expectedLabels = Math.floor(viewDuration / interval);
                const expectedSpacing = containerWidth / expectedLabels;
                
                while (expectedSpacing < minSpacing && interval < 3600) {
                    interval *= 2;
                }
                
                const startTime = Math.ceil(0 / interval) * interval;
                
                for (let t = startTime; t <= viewDuration; t += interval) {
                    const position = (t / viewDuration) * 100;
                    
                    if (position >= 0 && position <= 100) {
                        const tick = document.createElement('div');
                        tick.className = 'tick';
                        tick.style.left = `${position}%`;
                        
                        const label = document.createElement('span');
                        label.className = 'tick-label';
                        label.style.left = `${position}%`;
                        label.textContent = this.videoController.toSMPTE(t);
                        
                        timelineScale.appendChild(tick);
                        timelineScale.appendChild(label);
                    }
                }
                
                if (startTime > 0) {
                    const tick = document.createElement('div');
                    tick.className = 'tick';
                    tick.style.left = '0%';
                    
                    const label = document.createElement('span');
                    label.className = 'tick-label';
                    label.style.left = '0%';
                    label.textContent = this.videoController.toSMPTE(0);
                    
                    timelineScale.appendChild(tick);
                    timelineScale.appendChild(label);
                }
                
                const endTick = document.createElement('div');
                endTick.className = 'tick';
                endTick.style.left = '100%';
                
                const endLabel = document.createElement('span');
                endLabel.className = 'tick-label';
                endLabel.style.left = '100%';
                endLabel.textContent = this.videoController.toSMPTE(this.video.duration);
                
                timelineScale.appendChild(endTick);
                timelineScale.appendChild(endLabel);
            }
            
            async detectAudioInfo(video) {
                try {
                    if (!this.state.audioContext) {
                        this.state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const source = this.state.audioContext.createMediaElementSource(video);
                        source.connect(this.state.audioContext.destination);
                    }
                    return {
                        samplerate: this.state.audioContext.sampleRate,
                        channelcount: (video.mozChannels || video.webkitAudioChannelCount || 2)
                    };
                } catch (e) {
                    console.warn('Could not detect audio info:', e);
                    return { samplerate: 48000, channelcount: 2 };
                }
            }
            
            resetWaveform() {
                const waveformContainer = document.getElementById('waveform-scroll-container');
                const waveformMessage = document.getElementById('waveform-message');
                const loadingIndicator = document.getElementById('loading-indicator');
                
                this.state.importedWaveformData = null;
                this.videoController.state.isWaveformReady = false;
                
                if (waveformContainer) waveformContainer.style.display = 'none';
                if (waveformMessage) waveformMessage.style.display = 'none';
                if (loadingIndicator) loadingIndicator.style.display = 'none';
                
                if (this.videoController.wavesurfer) {
                    this.videoController.wavesurfer.destroy();
                    this.videoController.wavesurfer = null;
                    this.videoController.selectionRegion = null;
                }
            }
            
            // ============================================
            // CLEANUP
            // ============================================
            destroy() {
                // Clean up video controller
                if (this.videoController) {
                    this.videoController.destroy();
                }
                
                // Clean up video URL
                if (this.state.currentVideoUrl) {
                    URL.revokeObjectURL(this.state.currentVideoUrl);
                }
                
                // Close audio context
                if (this.state.audioContext && this.state.audioContext.state !== 'closed') {
                    this.state.audioContext.close();
                }
            }
        }
        
        // ============================================
        // INITIALIZE APPLICATION
        // ============================================
        const app = new AppController();
		window.app = app; // ADD THIS LINE to make app globally accessible
        
        // Ensure video controls are always visible
        const style = document.createElement('style');
        style.textContent = `
            video::-webkit-media-controls-panel {
                display: flex !important;
                opacity: 1 !important;
                visibility: visible !important;
            }
            video::-webkit-media-controls-timeline {
                display: flex !important;
                opacity: 1 !important;
                visibility: visible !important;
            }
            video::-webkit-media-controls {
                display: flex !important;
                opacity: 1 !important;
                visibility: visible !important;
            }
            video::-webkit-media-controls-enclosure {
                display: flex !important;
                opacity: 1 !important;
                visibility: visible !important;
            }
            video {
                /* Ensure controls are always shown */
                controls: true;
            }
            /* Firefox */
            video::-moz-media-controls-panel {
                opacity: 1 !important;
                visibility: visible !important;
            }
            /* Ensure the video element always has controls */
            #my_video {
                controls: true;
            }
            /* Prevent controls from being hidden on hover out */
            video:hover::-webkit-media-controls-panel,
            video::-webkit-media-controls-panel {
                opacity: 1 !important;
                transition: none !important;
            }
        `;
        document.head.appendChild(style);
        
        // Ensure the video element always has controls attribute
        const video = document.getElementById('my_video');
        if (video) {
            video.setAttribute('controls', 'true');
            video.setAttribute('controlsList', 'nodownload');
        }
        
        // Handle page unload
        window.addEventListener('beforeunload', function() {
            app.destroy();
        });
        
        // Handle window resize
        window.addEventListener('resize', app.debounce(function() {
            if (app.video.duration) {
                app.videoController.updateTimeDisplaysCached();
                app.updateTimelineScale();
            }
            
            // Adjust waveform zoom on resize
            if (app.videoController.state.isWaveformReady && app.videoController.wavesurfer) {
                const waveformContainer = document.getElementById('waveform-scroll-container');
                const isMobile = window.innerWidth <= 768;
                const pxPerSec = waveformContainer.clientWidth / (isMobile ? 15 : 5);
                app.videoController.wavesurfer.zoom(pxPerSec);
            }
        }, 250));
        
        // Prevent buttons from staying focused
        document.querySelectorAll('button').forEach(button => {
            button.addEventListener('click', function() {
                if (this !== app.playPauseBtn) {
                    setTimeout(() => this.blur(), 100);							
                }
            });
        });
    });
});
